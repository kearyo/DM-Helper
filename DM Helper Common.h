#if !defined(AFX_DMHELPERCOMMON_H__180AE6A1_F00E_4FB9_878D_216E96C10BB1__INCLUDED_)
#define AFX_DMHELPERCOMMON_H__180AE6A1_F00E_4FB9_878D_216E96C10BB1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#define DMH_CURRENT_VERSION 10033

#define USE_CANTRIPS	TRUE

#define ISOMETRIC_MAPS	TRUE

#define KEARY_BUILD	FALSE

//Dragon Magazines at http://www.annarchive.com/

/*  CHANGE LOG

- 1.0.000	3/26/14 
	* Initial release to Dragonsfoot

- 1.0.001	3/28/14
	* Corrected weights in armor.dat file, they were entered in "pounds" not "coins"
	* Modified CalculateEncumbrance function to validate existing item weights because of above change
	* Fixed a couple of crasher bugs on party dialog
	* Fixed multiple NPCs being listed in character selection dialog
	* Added random seed to random number generator
	* Fixed window size problem when creating a new character

- 1.0.002	4/3/14
	* Removed non-functional Load Party button on party screen
	* Added dice roller window
	* Added copy and paste of NPC's in a party
	* Added XP to Monster Manual entries
	* Fixed errors in thief skill lookups
	* Fixed bug where first spell in spell list could not be copied to spellbook
	
- 1.0.003	4/18/14
	* DONE need to add helmets to equipment list ! - DONE
	* DONE MAKE SURE calendar_data.dat is added to release, this is a new file ! and remove calendars.dat
	* DONE Add birthday info to character sheet notes - DONE
	* DONE fix issue where newly created party does not show up in opposing party list of other parties - FIXED
	* DONE opposing party missile weapons not updating on party view, example was NPC thrown dagger - FIXED
	* DONE changed party should prompt for save before closing
	* DONE changed maps (caches included) should prompt for save before closing
	* DONE map filename does not appear in selection box when saving maps
	* DONE IsNPC checkbox does not update on init on char view screen FIXED

- 1.0.004	4/25/14
	* DONE party experience etc. not awarding unless there is a party log
	* DONE crasher bug when editing maps
	* DONE New map tab name does not update with map name change
	* DONE New cache tab name does not update with cache name change

- 1.0.005	5/16/14
	* Various crasher bug fixes for NPC tabs
	* Treasure types added for monsters
	* NOTE  druid spell list modified

- 1.0.006	6/2/14
	* Moon phases added to calendars
	* Magical items from DMG added to object lists

	* TODO for release
	* Add magic_items.dat to install
	* rings.dat modified
	* equipment.dat modified

- 1.0.007	6/12/14
	* TODO - bug where newly created NPC does not have correct type of inventory view - FIXED
	* TODO - equipment.dat is modified for this release
	* TODO - magic_items.dat is modified for this release
	* TODO - to be safe, update all table files for this release
	* Added scrolls, rods, staves, wands and containers

- 1.0.008	6/17/14
	* Fixed crasher bug in cache cleanup on closing maps
	* Level limits now actually work
	* Changed encumbrance calc so armor worn movement rate is maximum allowed movement rate regardless of strength

- 1.0.009	8/20/14
	* DONE MonsterManual.dat must be updated
	* DONE Encounter Table .dat files must be added
	* TODO blue_dungeon_bitmap.png must be added
	* TODO black_dungeon_bitmap.png must be added
	* DONE need to be able to clean up caches in random maps 
	* DONE fix bug inventory coin/stacked item transfer
	* DONE tile map edit does not work if view is zoomed
	* DONE validate that copy / paste NPC still works
	* DONE add real time clock
	* DONE red dragon cannot have 11 hitpoints in a level 10 dungeon !
	* DONE equip NPC generated characters for DMG pg. 175
	* DONE need to put dungeon generated characters "in pocket" for save and load of the party
	* DONE BUG go from char view to select new map from menu, program loses its shit - send SW_HIDE to current window before popping up map window to prevent OnPaint race condition
	* TODO Fix bug, ftr/thief/illusionist levels 3/3/0 ????
	* DONE Need secret door icons in map editor
	* DONE? party screen not updating ammo counts
	* FIXED ? ordering of multiclass chars ?  MU/Thief/Fighter ? is possible, is this bad ? - example character had no armor for instance
	* FIXED  - only females being generated by random monster manual encounters
	* FIXED - editing XP values on character view screen
	* FIXED - multiclass characters - fighter/assassin in a party with a paladin/ranger or vice versa

- 1.0.010	8/29/14
	* DONE BUG - switch to map view can make entire app hidden
	* DONE BUG - autoscale map to parent is not working
	* ADDED measuring tool to map view (SHIFT + drag)
	* HAPPY BIRTHDAY SUGARBUTT !

- 1.0.011	4/19/14
	* CRITICAL - CURL DLLs must be in new install !
	* FIXED - Monks needed some love - movement rates, armor class calc, weapon damage and house rules
	* Added update system

- 1.0.012	9/26/14
	* FIXED typo in Data/tables/weapons.dat (horseman's mace entry)
	* Corrected entry for sling stone damage
	* ADDING MMII and Fiend Folio
	* TODO MonsterManual.dat is updated
	* TODO RandomEncounterTables.dat is updated
	* TODO Data/tables/names/random_names.dat is updated
	* FIXED HD calcs for MMII and FF are sometimes incorrect

- 1.0.013	9/29/14
	* FIXED bugs in spell selection screen for multiclass characters

- 1.0.014	10/8/14
	* FIXED more bugs in spell selection screen for multiclass characters
	* ADDED cantrips and orisons, spells.dat files must be part of update !
	* ADDED weapons vs. AC data - weapons.dat must be part of update !
	* ADDED some equipment items from rangert's suggestions

- 1.0.015	10/8/14
	* FIXED bug with character sheet WvsAC calculations
	* Added "Small Font" selection on main screen for smaller screen resolutions cutting off some screen controls

- 1.0.016	11/4/14
	* ADDED Object ID'd attribute to hide stuff on character sheet
	* FIXED bug where a cache could not be deleted
	* FIXED bug where you could not assign a bitmap to a map cell if the view was zoomed out
	* Added magical sword abilities, languages, special purposes etc.
	* Added treasure type selection button to cache inventory views

- 1.0.017	11/6/14
	* FIXED issue with magic sword selection on inventory screen
	* FIXED issue with Druid spells by level returning cleric values

- 1.0.018	12/3/14
	* FIXED crasher bug when deleting party NPCs
	* Added Weapon Specialization
	* Added editors for custom objects, spells, monsters

- 1.0.019	1/6/15
	* FIXED bug with updating character details when tabbing to another character view
	* FIXED bug where target's shield was not taken into account for Weapon vs AC calculations 

- 1.0.020	1/16/15
	* FIXED bug where NPC weapon swap on party view did not correctly update weapon damage
	* FIXED bug where multi classed character experience points did not update correctly when entered with +/- button for classes beyond the first class

- 1.0.021	4/27/15
	* FIXED bug where rings of protection were incorrectly stacking with magical armor
	* FIXED bug where 0 level catrips/orisons could display as negative numbers of available spell slots

- 1.0.022	6/30/15
	* FIXED crasher bug when closing character when character details view is open

- 1.0.023	9/14/15
	* FIXED error in protection scroll descriptions (update MUST include magic_items.dat !)
	* FIXED error in cleric_spells.dat
	* FIXED error in illusionist_spells.dat
	* ADDED Custom weapons editor
	
- 1.0.024	9/14/15
	* MFC DLL compatibility fix

- 1.0.025	9/16/15
	* FIXED bug introduced by custom weapon editor where magic items were mapped to the incorrect mundane item, i.e. a +1 protection ring could not be worn as a ring
	
- 1.0.026	10/23/15
	* DONE Party log screen should respond to mouse wheel scroll
	* Added subdirectory capability to load/save characters/parties/maps
	* Added transparent layer capability to maps
	* Added character portraits to NPC views
	* Added magic item description lookups (MUST INCLUDE NEW FILE IN UPDATE PATCH !!!!)
	* MagicItems.dat changed - include in update !
	* DONE Add msvcp dll to update patch
	* DONE bracers of defense need some love

- 1.0.027	10/27/15
	* Fixed bug where creating a new map did not set layer transparency values correctly
	* Fixed error where armor.dat was erased by the installer

- 1.0.028	12/17/16
	* Fixed bug where XP bonus for high prime requisite stats was calculated incorrectly
	* Fixed bug where HD+ values for monsters was not calculating hitpoints correctly

- 1.0.029	5/19/17
	* Fixed bug where saving throws were not being calculated correctly for dual classed characters
	* Added 'stat block' party summaries that can be copy/pasted from the program

- 1.0.030	9/14/17
	* Added capability to detach maps from the main program for display on external monitor
	* Added functionality to cut cell maps from large bitmap directly from map editor

- 1.0.033	10/11/18
	* Added fog of war capability for detached maps
	* Added special effect capability for maps (SFX) (adding animated GIF's to a map)
	* Double sided printing enabled for character sheets
	* Bug fixes for errors caused by adding and removing / copy/ pasting NPCs into parties


*/

#define PCSTRING CString*
typedef CTypedPtrMap <CMapWordToPtr, WORD, PCSTRING> PCSTRINGMAP;

//global variables (yeah I know, so sue me)

#define PI 3.14159265358979323846f

extern BOOL g_bUseUnearthedArcana;
extern BOOL g_bUseDemiHumanLevelLimits;
extern BOOL g_bReRollOnesOnHitDie;
extern BOOL g_bReRollLessHalfOnHitDie;
extern BOOL g_bMaxHitPointsAtFirstLevel;
extern BOOL g_bUsed10Initiative;
extern BOOL g_bUseSoundEffects;

#define ATTRIB_STR		0
#define ATTRIB_INT		1
#define ATTRIB_WIS		2
#define ATTRIB_DEX		3
#define ATTRIB_CON		4
#define ATTRIB_CHA		5
#define ATTRIB_COM		6
#define ATTRIB_EXSTR	7


float GetDistance(float x1, float y1, float x2, float y2); 

int RollD3();
int RollD4();
int RollD6();
int RollD8();
int RollStat();

int RollD10();
int RollD12();
int RollD20();
int RollD00();
int RollD100();

int nRollDie(int nDieType);


typedef enum
{
	DND_CHARACTER_RACES_UNDEF = 0,

	DND_CHARACTER_RACE_HUMAN, 

	DND_CHARACTER_RACE_ELF,

	DND_CHARACTER_RACE_HALF_ELF,

	DND_CHARACTER_RACE_DWARF,

	DND_CHARACTER_RACE_HALFLING,

	DND_CHARACTER_RACE_GNOME,

	DND_CHARACTER_RACE_HALF_ORC,
	
	DND_CHARACTER_RACE_DROW,

	DND_CHARACTER_RACE_LAST_RACE,

	DND_CHARACTER_RACE_HALFLING_TALLFELLOW = 51,
	DND_CHARACTER_RACE_HALFLING_STOUT = 52,

	DND_CHARACTER_FIRST_MONSTER = 1000,

} DND_CHARACTER_RACES;


char *GetRaceName(DND_CHARACTER_RACES nRace);



typedef enum
{
	DND_CHARACTER_CLASS_UNDEF = 0,

	DND_CHARACTER_CLASS_FIGHTER = 100, 
	DND_CHARACTER_CLASS_RANGER = 110,
	DND_CHARACTER_CLASS_CAVALIER = 120,
	DND_CHARACTER_CLASS_PALADIN = 121,
	DND_CHARACTER_CLASS_BARBARIAN = 130,

	DND_CHARACTER_CLASS_CLERIC = 200,
	DND_CHARACTER_CLASS_DRUID = 210,
	DND_CHARACTER_CLASS_MONK = 220,

	DND_CHARACTER_CLASS_THIEF = 300,
	DND_CHARACTER_CLASS_THIEF_ACROBAT = 301,
	DND_CHARACTER_CLASS_ASSASSIN = 310,

	DND_CHARACTER_CLASS_MAGE = 400,
	DND_CHARACTER_CLASS_ILLUSIONIST = 410,

	DND_CHARACTER_SPELL_CLASS_RANGER_DRUID = 1000,
	DND_CHARACTER_SPELL_CLASS_RANGER_MAGE = 1001,
	DND_CHARACTER_SPELL_CLASS_PALADIN_CLERIC = 2000,

	DND_CHARACTER_CLASS_MONSTER = 5000,


} DND_CHARACTER_CLASSES;


char *GetClassName(DND_CHARACTER_CLASSES nClass);


typedef enum
{
	DND_CHARACTER_ALIGNMENT_UNDEF = 0,

	DND_CHARACTER_ALIGNMENT_LAWFUL_GOOD,
	DND_CHARACTER_ALIGNMENT_NEUTRAL_GOOD,
	DND_CHARACTER_ALIGNMENT_CHAOTIC_GOOD,

	DND_CHARACTER_ALIGNMENT_LAWFUL_NEUTRAL,
	DND_CHARACTER_ALIGNMENT_NEUTRAL,
	DND_CHARACTER_ALIGNMENT_CHAOTIC_NEUTRAL,

	DND_CHARACTER_ALIGNMENT_LAWFUL_EVIL,
	DND_CHARACTER_ALIGNMENT_NEUTRAL_EVIL,
	DND_CHARACTER_ALIGNMENT_CHAOTIC_EVIL,

} DND_CHARACTER_ALIGNMENTS;

char *GetAlignmentName(DND_CHARACTER_ALIGNMENTS nAlignment);
char *GetShortAlignmentName(DND_CHARACTER_ALIGNMENTS nAlignment);

BOOL IsAlignmentGood(DND_CHARACTER_ALIGNMENTS nAlignment);
BOOL IsAlignmentEvil(DND_CHARACTER_ALIGNMENTS nAlignment);

typedef enum
{
	DND_CHARACTER_VISION_UNDEF = 0,

	DND_CHARACTER_VISION_STANDARD,

	DND_CHARACTER_VISION_30_INF,
	DND_CHARACTER_VISION_60_INF,

	DND_CHARACTER_VISION_120_INF,

	DND_CHARACTER_VISION_120_INF_UV,

	DND_CHARACTER_VISION_UV,

	DND_CHARACTER_VISION_SPECIAL,

	DND_CHARACTER_VISION_LAST_TYPE


} DND_CHARACTER_VISION_TYPES;

char *GetVisionTypeName(DND_CHARACTER_VISION_TYPES nVision);


typedef enum
{
	PLATINUM_PIECES = 0,

	GOLD_PIECES,

	ELECTRUM_PIECES,

	SILVER_PIECES,

	COPPER_PIECES,

	DND_COINS_ALL

} DND_COIN_TYPES;


#define APPEND_TO_LOG	-1

typedef enum
{
	DND_LOG_EVENT_TYPE_UNDEFINED = 0,

	DND_LOG_EVENT_TYPE_NEW_GAME_SESSION,

	DND_LOG_EVENT_TYPE_GAME_SESSION_ENDED,

	DND_LOG_EVENT_TYPE_CHARACTER_CAST_SPELL,

	DND_LOG_EVENT_TYPE_CHARACTER_GAINED_XP,

	DND_LOG_EVENT_TYPE_CHARACTER_GAINED_XP_COMBAT,

	DND_LOG_EVENT_TYPE_CHARACTER_GAINED_XP_CLASS_SKILL,

	DND_LOG_EVENT_TYPE_CHARACTER_GAINED_XP_ROLEPLAY,

	DND_LOG_EVENT_TYPE_CHARACTER_GAINED_XP_TREASURE,

	DND_LOG_EVENT_TYPE_CHARACTER_LOST_XP,

	DND_LOG_EVENT_TYPE_CHARACTER_TRAINED,

	DND_LOG_EVENT_TYPE_CHARACTER_GAINED_LEVEL,

	DND_LOG_EVENT_TYPE_CHARACTER_LOST_LEVEL,

	DND_LOG_EVENT_TYPE_CHARACTER_DIED,

	DND_LOG_EVENT_TYPE_CHARACTER_RAISED,

	DND_LOG_EVENT_TYPE_CHARACTER_JOINED_PARTY,

	DND_LOG_EVENT_TYPE_CHARACTER_LEFT_PARTY,

	DND_LOG_EVENT_TYPE_PARTY_GAINED_XP,

	DND_LOG_EVENT_TYPE_PARTY_GAINED_XP_COMBAT,

	DND_LOG_EVENT_TYPE_PARTY_GAINED_XP_TREASURE,

	DND_LOG_EVENT_TYPE_PARTY_LOST_XP,

	DND_LOG_EVENT_TYPE_PARTY_FOUNDED,

	DND_LOG_EVENT_TYPE_PARTY_BEGAN_JOURNEY,

	DND_LOG_EVENT_TYPE_PARTY_TRAVELED,

	DND_LOG_EVENT_TYPE_PARTY_FINISHED_JOURNEY,

	DND_LOG_EVENT_TYPE_PARTY_RESTED,

	DND_LOG_EVENT_TYPE_MISC,

	DND_LOG_EVENT_TYPE_LAST_EVENT_TYPE,

} DND_LOG_EVENT_TYPES;

char *GetLogEventName(DND_LOG_EVENT_TYPES nEventType);
char *GetLogEventDesc(DND_LOG_EVENT_TYPES nEventType);
int GetLanguageIndex(char *szLanguage);
int GetRandomLanguageIndex();

#define MAX_LOG_EVENTS	2048

class cDNDPartyLogEvent
{
public:

	time_t m_tEventID;

	DND_LOG_EVENT_TYPES m_EventType;

	int m_nMonth;
	int m_nDay;
	int m_nYear;

	int m_nHour;
	int m_nTurn;
	int m_nRound;
	int m_nSegment;

	DWORD m_dwPartyID;
	DWORD m_dwCharacterID;

	LONG m_lAmount;
	LONG m_lAmountRemaining;

	char m_szName[64];
	char m_szComment[128];

	int m_nReserved[1024];

	cDNDPartyLogEvent()
	{
		m_tEventID = 0;

		m_EventType = DND_LOG_EVENT_TYPE_UNDEFINED;

		m_nMonth = 0;
		m_nDay = 0;
		m_nYear = 0;

		m_nHour = 0;
		m_nTurn = 0;
		m_nRound = 0;
		m_nSegment = 0;

		m_dwPartyID = 0L;
		m_dwCharacterID = 0L;

		m_lAmount = 0L;
		m_lAmountRemaining = 0L;

		memset(m_szName, 0, 64 * sizeof(char));
		memset(m_szComment, 0, 128 * sizeof(char));

		memset(m_nReserved, 0, 1024*sizeof(int));
	};

	~cDNDPartyLogEvent()
	{
	};
};


class cDNDPartyLogHeader
{
public:

	UINT	m_Version;
	DWORD m_dwPartyID;
	int m_nEvents;

	int m_nReserved[2048];

	cDNDPartyLogHeader()
	{
		m_Version = DMH_CURRENT_VERSION;
		m_dwPartyID = 0L;

		m_nEvents = 0;

		memset(m_nReserved, 0, 2048*sizeof(int));
	};

	~cDNDPartyLogHeader()
	{
	};
};


class cDNDPartyLog
{
public:

	cDNDPartyLogHeader m_LogHeader;

	cDNDPartyLogEvent m_Event[MAX_LOG_EVENTS];

	int m_nReserved[1024];

	cDNDPartyLog()
	{
		memset(m_nReserved, 0, 1024*sizeof(int));
	};

	~cDNDPartyLog()
	{
		TRACE("DELETING LOG !\n");
	};

	void ValidateEvents();
	void DeleteEvent(int nEvent);
	
};


/////////////////////////////////////////////////////////////////

typedef enum
{
	DND_CALENDAR_MOD_SECOND = 0,
	DND_CALENDAR_MOD_SEGMENT,
	DND_CALENDAR_MOD_ROUND,
	DND_CALENDAR_MOD_TURN,
	DND_CALENDAR_MOD_HOUR,
	DND_CALENDAR_MOD_DAY,
	DND_CALENDAR_MOD_MONTH,
	DND_CALENDAR_MOD_YEAR,

	DND_CALENDAR_MOD_INIT,
	DND_CALENDAR_MOD_DECREMENT,
	DND_CALENDAR_MOD_INCREMENT,
	DND_CALENDAR_MOD_SET

} DND_CALENDAR_MOD_TYPES;


#define MAX_CALENDAR_MONTHS	128
#define MAX_CALENDAR_DAYS_IN_WEEK	32
#define MAX_CALENDAR_DAYS_IN_MONTH	128
#define MAX_CALENDAR_MONTHS_IN_YEAR	128
#define MAX_CALENDAR_HOLIDAYS		365

#define MAX_CALENDAR_MOONS			3
#define MAX_CALENDAR_MOON_PHASES	8

class cDNDCalendarHoliday
{
public:

	int m_nMonth;
	int m_nDay;
	char m_szDesc[64];

	cDNDCalendarHoliday()
	{
		m_nMonth = -1;
		m_nDay = -1;

		memset(m_szDesc, 0, 64*sizeof(char));
	};

	~cDNDCalendarHoliday()
	{
	};
};


class cDNDCalendar
{
public:
	DWORD	m_dwCalendarID;

	char m_szCalendarName[64];

	int m_nBaseYear;
	
	int m_nDaysInWeek;
	char m_szDayNames[MAX_CALENDAR_DAYS_IN_WEEK][32];

	int m_nMonthsInYear;
	char m_szMonthNames[MAX_CALENDAR_MONTHS_IN_YEAR][32];
	int m_nDaysInMonth[MAX_CALENDAR_MONTHS_IN_YEAR];

	int m_nLeapYearMonth;
	int m_nLeapYearDivisor;
	int m_nLeapYearExceptionDivisor;
	int m_nLeapYearExceptionExceptionDivisor;
	int m_nCalendarStartsOnDayOfWeek;

	int m_nNumHolidays;
	cDNDCalendarHoliday m_Holidays[MAX_CALENDAR_HOLIDAYS];

	int m_nMoons;
	char m_szMoonName[MAX_CALENDAR_MOONS][32];
	int m_nMoonPhases[MAX_CALENDAR_MOONS];
	char m_szMoonPhaseName[MAX_CALENDAR_MOONS][MAX_CALENDAR_MOON_PHASES][32];
	float m_fMoonPhasePoint[MAX_CALENDAR_MOONS][MAX_CALENDAR_MOON_PHASES];
	int m_nMoonPhaseSymbol[MAX_CALENDAR_MOONS][MAX_CALENDAR_MOON_PHASES];
	float m_fMoonCycle[MAX_CALENDAR_MOONS];
	float m_fMoonCycleBase[MAX_CALENDAR_MOONS];

	cDNDCalendar()
	{
		m_dwCalendarID = 0;

		memset(m_szCalendarName, 0, 64*sizeof(char));
		m_nBaseYear = 0;
		
		m_nDaysInWeek = 0;
		memset(m_szDayNames, 0, MAX_CALENDAR_DAYS_IN_WEEK*32*sizeof(char));
		
		m_nMonthsInYear = 0;
		memset(m_szMonthNames, 0, MAX_CALENDAR_MONTHS_IN_YEAR*32*sizeof(char));
		memset(m_nDaysInMonth, 0, MAX_CALENDAR_MONTHS_IN_YEAR*sizeof(int));

		m_nLeapYearMonth = 0;
		m_nLeapYearDivisor = 0;
		m_nLeapYearExceptionDivisor = 0;
		m_nLeapYearExceptionExceptionDivisor = 0;
		m_nCalendarStartsOnDayOfWeek = 0;

		m_nNumHolidays = 0;

		//moonie moonie
		m_nMoons = 0;
		memset(m_szMoonName, 0, MAX_CALENDAR_MOONS*32*sizeof(char));
		memset(m_nMoonPhases, 0,  MAX_CALENDAR_MOONS * sizeof(int));
		memset(m_szMoonPhaseName, 0, MAX_CALENDAR_MOONS*MAX_CALENDAR_MOON_PHASES*32*sizeof(char));
		memset(m_nMoonPhaseSymbol, 0, MAX_CALENDAR_MOONS*MAX_CALENDAR_MOON_PHASES*sizeof(int));
		memset(m_fMoonPhasePoint, 0, MAX_CALENDAR_MOONS*MAX_CALENDAR_MOON_PHASES*sizeof(float));
		memset(m_fMoonCycle, 0, MAX_CALENDAR_MOONS*sizeof(float));
		memset(m_fMoonCycleBase, 0, MAX_CALENDAR_MOONS*sizeof(float));

	}

	~cDNDCalendar()
	{
	}

	void Initialize();
	BOOL IsLeapYear(int nFindYear);
	int FindDayOfWeek(int nFindMonth, int nFindDayofMonth, int nFindYear);
	float GetMoonCycleDay(int nMoon, int nFindMonth, int nFindDayofMonth, int nFindYear, float fCycleStart = 999.9f);
	float IncrementMoonDay(int nMoon, float fMoonDay);
	int GetMoonPhase(int nMoon, float fMoonDay);

};

#define PCALENDAR cDNDCalendar*
typedef CTypedPtrArray <CPtrArray, PCALENDAR> PCALENDARARRAY;

typedef enum
{
	DND_INVENTORY_LOCATION_LEFT,
	DND_INVENTORY_LOCATION_CENTER,
	DND_INVENTORY_LOCATION_RIGHT

} DND_INVENTORY_LOCATION_TYPES;

typedef enum
{
	DND_OBJECT_TYPE_OBJECT = 0,
	DND_OBJECT_TYPE_ARMOR,
	DND_OBJECT_TYPE_SHIELD,
	DND_OBJECT_TYPE_WEAPON,
	DND_OBJECT_TYPE_AMMO,

	DND_OBJECT_TYPE_EQUIPMENT,
	DND_OBJECT_TYPE_RING,
	DND_OBJECT_TYPE_ROD_STAFF,

	DND_OBJECT_TYPE_HELMET,

	DND_OBJECT_TYPE_CUSTOM,

	DND_OBJECT_TYPE_LAST_TYPE,

} DND_OBJECT_TYPES;


#define MAX_WEAPONS_DEFINED			256
#define MAX_CHARACTER_INVENTORY		128
#define MAX_WEAPON_PROFICIENCIES	20
#define MAX_CHARACTER_LANGUAGES		16

#define MAX_OBJECT_CONTENTS		50

class cDNDObject
{
public:

	WORD m_wTypeId;
	DWORD	m_dwObjectID;
	DND_OBJECT_TYPES m_ObjectType;
	char m_szType[32]; 
	int m_nWeight;
	int m_nMagicAdj;
	int m_nCharges;
	int m_nCost;
	LONG m_lAmount;
	int m_nFlags;

	unsigned long m_lXP;

	BOOL m_bEnchanted;		//this means that the item came from the "magic items" list

	int m_nContents[MAX_OBJECT_CONTENTS];			// currently scroll data and charged magic items, can be used for other stuff as needed, first off is magic sword languages contents (0-MAX_CHARACTER_LANGUAGES)
	int m_nContentsCount[MAX_OBJECT_CONTENTS];		// currently can be used for other stuff as needed, first off is magic sword communication ability  (0-communication flags)

	DWORD m_dwContainerID;
	int m_nContainerPlatinum;
	int m_nContainerGold;
	int m_nContainerElectrum;
	int m_nContainerSilver;
	int m_nContainerCopper;

	int m_nItemValue;

	char m_szExtendedName[128];

	BOOL m_bMysteryItem;

	//magic sword stuff
	int m_nIntelligence;
	DND_CHARACTER_ALIGNMENTS m_Alignment;

	char m_szPrimaryAbility[3][128];
	char m_szExtraordinaryPower[128];
	char m_szSpecialPurpose[128];
	char m_szSpecialPurposePower[128];

	unsigned int m_nCustomFlags;		// flag 000001 is a custom sword

	int m_nReserved[687];	// was 882

	cDNDObject()
	{
		Init();
	}

	~cDNDObject()
	{
	}

	void Init()
	{
		m_wTypeId = 0;
		m_dwObjectID = 0L;	//unique to each 'real' object
		m_ObjectType = DND_OBJECT_TYPE_OBJECT;
		memset(m_szType, 0, 32 * sizeof(char)); 
		m_nWeight = 0;
		m_nMagicAdj = 0;
		m_nCharges = 0;
		m_nCost = 0;
		m_lAmount = 0L;
		m_nFlags = 0;

		m_lXP = 0L;

		m_bEnchanted = FALSE;

		memset(m_nContents, 0, MAX_OBJECT_CONTENTS*sizeof(int));
		memset(m_nContentsCount, 0, MAX_OBJECT_CONTENTS*sizeof(int));

		m_dwContainerID = 0;
		m_nContainerPlatinum = 0;
		m_nContainerGold = 0;
		m_nContainerElectrum = 0;
		m_nContainerSilver = 0;
		m_nContainerCopper = 0;

		m_nItemValue = 0;

		memset(m_szExtendedName, 0, 128*sizeof(char));

		m_bMysteryItem = FALSE;

		//magic sword stuff
		m_nIntelligence = 0;
		m_Alignment = DND_CHARACTER_ALIGNMENT_UNDEF;

		memset(m_szPrimaryAbility, 0, 3*128*sizeof(char));
		memset(m_szExtraordinaryPower, 0, 128*sizeof(char));
		memset(m_szSpecialPurpose, 0, 128*sizeof(char));
		memset(m_szSpecialPurposePower, 0, 128*sizeof(char));

		m_nCustomFlags = 0;

		memset(m_nReserved, 0, 687 * sizeof(int));
	}

	char *GetExtendedName()
	{
		if(m_szExtendedName[0] != 0)
			return m_szExtendedName;

		return m_szType;
	}

	BOOL IsRations()
	{
		int nFlags = m_nFlags;
		nFlags = (nFlags / 10000)%10000;

		if(nFlags == 5) //this is a ration
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsContainer()
	{
		int nFlags = m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 1) //this is a container
		{
			return TRUE;
		}
		if(nFlags == 2) //this is a magic bag, see below
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsCoinContainer()
	{
		if(IsContainer())
		{
			if(m_nContainerPlatinum || 	m_nContainerGold || m_nContainerElectrum || m_nContainerSilver || m_nContainerCopper)
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	LONG GetCoinWeight()
	{
		return (LONG) (m_nContainerPlatinum + m_nContainerGold + m_nContainerElectrum + m_nContainerSilver + m_nContainerCopper);
	}
	
	BOOL IsScroll()
	{
		int nFlags = m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 3) //this is a scroll
		{
			return TRUE;
		}

		return FALSE;
	}

	void RenameScroll();
	void PopulateRandomScroll();

	BOOL IsMagicRod()
	{
		int nFlags = m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 4) //this is a magic rod
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsMagicStaff()
	{
		unsigned int nFlags = (unsigned int)m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 5) //this is a magic staff
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsMagicWand()
	{
		unsigned int nFlags = (unsigned int)m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 6) //this is a magic wand
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsMagicRing()
	{
		unsigned int nFlags = (unsigned int)m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 7) //this is a magic ring that contains spells and charges
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsMagicContainer()
	{
		return ( IsScroll() || IsMagicRod() | IsMagicStaff() | IsMagicWand() | IsMagicRing() );
	}

	
	BOOL UsesMagicCharges()
	{
		return ( IsMagicRod() | IsMagicStaff() | IsMagicWand() | IsMagicRing() );
	}

	BOOL IsMagicBag()
	{
		int nFlags = m_nFlags;
		nFlags = (nFlags / 100000)%100000;

		if(nFlags == 2) //this is a magic bag (bag of holding / portable hole)
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL IsSword()
	{
		if(m_wTypeId >= 1150 && m_wTypeId <= 1154)
		{
			return TRUE;
		}

		if ((m_nCustomFlags & 0x0001) == 1)
		{
			return TRUE;
		}

		return FALSE;
	}

	BOOL CanSpeakLanguage(int nLanguage) // this is for intelligent swords
	{
		for(int i = 0; i < MAX_CHARACTER_LANGUAGES; ++i)
		{
			if(m_nContents[i] == nLanguage)
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOL PushContents(int nContent, int nCount = 1)
	{
		for(int i = 0; i < MAX_OBJECT_CONTENTS; ++i)
		{
			if(m_nContents[i] == nContent)
			{
				m_nContentsCount[i] += nCount;
				return TRUE;
			}
		}

		for(int i = 0; i < MAX_OBJECT_CONTENTS; ++i)
		{
			if(m_nContents[i] == 0)
			{
				m_nContents[i] = nContent;
				m_nContentsCount[i] = nCount;
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOL PopContents(int nContent)
	{
		for(int i = 0; i < MAX_OBJECT_CONTENTS; ++i)
		{
			if(m_nContents[i] == nContent)
			{
				--m_nContentsCount[i];

				if(m_nContentsCount[i] <= 0)
				{
					m_nContents[i] = 0;
					CollapseContents();
				}

				return TRUE;
			}
		}

		return FALSE;
	}

	void CollapseContents()
	{
		int _nContents[MAX_OBJECT_CONTENTS];
		int _nContentsCount[MAX_OBJECT_CONTENTS];

		memset(_nContents, 0, MAX_OBJECT_CONTENTS*sizeof(int));
		memset(_nContentsCount, 0, MAX_OBJECT_CONTENTS*sizeof(int));

		int nIndex = 0;
		for(int i = 0; i < MAX_OBJECT_CONTENTS; ++i)
		{
			if(m_nContentsCount[i])
			{
				_nContents[nIndex] = m_nContents[i];
				_nContentsCount[nIndex] = m_nContentsCount[i];
				++nIndex;
			}
		}

		for(int i = 0; i < MAX_OBJECT_CONTENTS; ++i)
		{
			m_nContents[i] = _nContents[i];
			m_nContentsCount[i] = _nContentsCount[i];
		}
	}

	void CopyTo(cDNDObject *pDestObject)
	{
		cDNDObject *pSourceObject = this;

		if(pDestObject == NULL)
		{
			pDestObject = new cDNDObject();
		}

		pDestObject->m_wTypeId = pSourceObject->m_wTypeId;
		pDestObject->m_ObjectType = pSourceObject->m_ObjectType;
		memcpy(pDestObject->m_szType, pSourceObject->m_szType, 32 * sizeof(char)); 
		pDestObject->m_nCharges = pSourceObject->m_nCharges;
		pDestObject->m_nWeight = pSourceObject->m_nWeight;
		pDestObject->m_nCost = pSourceObject->m_nCost;
		pDestObject->m_lAmount = pSourceObject->m_lAmount;
		pDestObject->m_nFlags = pSourceObject->m_nFlags;
		pDestObject->m_lXP = pSourceObject->m_lXP;
		pDestObject->m_bEnchanted = pSourceObject->m_bEnchanted;

		memcpy(pDestObject->m_nContents, pSourceObject->m_nContents, MAX_OBJECT_CONTENTS*sizeof(int));
		memcpy(pDestObject->m_nContentsCount, pSourceObject->m_nContentsCount, MAX_OBJECT_CONTENTS*sizeof(int));

		pDestObject->m_dwContainerID = pSourceObject->m_dwContainerID;

		pDestObject->m_nContainerPlatinum = pSourceObject->m_nContainerPlatinum;
		pDestObject->m_nContainerGold = pSourceObject->m_nContainerGold;
		pDestObject->m_nContainerElectrum = pSourceObject->m_nContainerElectrum;
		pDestObject->m_nContainerSilver = pSourceObject->m_nContainerSilver;
		pDestObject->m_nContainerCopper = pSourceObject->m_nContainerCopper;
		pDestObject->m_nItemValue = pSourceObject->m_nItemValue;

		memcpy(pDestObject->m_szExtendedName, pSourceObject->m_szExtendedName, 128 * sizeof(char)); 

		pDestObject->m_bMysteryItem = pSourceObject->m_bMysteryItem;

		pDestObject->m_nIntelligence = pSourceObject->m_nIntelligence;
		pDestObject->m_Alignment = pSourceObject->m_Alignment;

		memcpy(pDestObject->m_szPrimaryAbility, pSourceObject->m_szPrimaryAbility, 3*128*sizeof(char));
		memcpy(pDestObject->m_szExtraordinaryPower, pSourceObject->m_szExtraordinaryPower, 128*sizeof(char));
		memcpy(pDestObject->m_szSpecialPurpose, pSourceObject->m_szSpecialPurpose, 128*sizeof(char));
		memcpy(pDestObject->m_szSpecialPurposePower, pSourceObject->m_szSpecialPurposePower, 128*sizeof(char));

		pDestObject->m_nCustomFlags = pSourceObject->m_nCustomFlags;
	}
	void CopyBase(cDNDObject *pSourceObject, cDNDObject *pDestObject)
	{
		if(pDestObject == NULL)
		{
			pDestObject = new cDNDObject();
		}

		pDestObject->m_wTypeId = pSourceObject->m_wTypeId;
		pDestObject->m_ObjectType = pSourceObject->m_ObjectType;
		memcpy(pDestObject->m_szType, pSourceObject->m_szType, 32 * sizeof(char)); 
		pDestObject->m_nCharges = pSourceObject->m_nCharges;
		pDestObject->m_nWeight = pSourceObject->m_nWeight;
		pDestObject->m_nCost = pSourceObject->m_nCost;
		pDestObject->m_lAmount = pSourceObject->m_lAmount;
		pDestObject->m_nFlags = pSourceObject->m_nFlags;
		pDestObject->m_lXP = pSourceObject->m_lXP;
		pDestObject->m_bEnchanted = pSourceObject->m_bEnchanted;

		memcpy(pDestObject->m_nContents, pSourceObject->m_nContents, MAX_OBJECT_CONTENTS*sizeof(int));
		memcpy(pDestObject->m_nContentsCount, pSourceObject->m_nContentsCount, MAX_OBJECT_CONTENTS*sizeof(int));

		memcpy(pDestObject->m_nContentsCount, pSourceObject->m_nContentsCount, MAX_OBJECT_CONTENTS*sizeof(int));

		memcpy(pDestObject->m_szExtendedName, pSourceObject->m_szExtendedName, 128 * sizeof(char)); 

		pDestObject->m_nCustomFlags = pSourceObject->m_nCustomFlags;
	}
	void CopyFull(cDNDObject *pDestObject)
	{
		cDNDObject *pSourceObject = this;

		if(pDestObject == NULL)
		{
			pDestObject = new cDNDObject();
		}

		pDestObject->m_wTypeId = pSourceObject->m_wTypeId;
		pDestObject->m_dwObjectID = pSourceObject->m_dwObjectID;
		pDestObject->m_ObjectType = pSourceObject->m_ObjectType;
		memcpy(pDestObject->m_szType, pSourceObject->m_szType, 32 * sizeof(char)); 
		pDestObject->m_nWeight = pSourceObject->m_nWeight;
		pDestObject->m_nMagicAdj = pSourceObject->m_nMagicAdj;	
		pDestObject->m_nCharges = pSourceObject->m_nCharges;
		pDestObject->m_nCost = pSourceObject->m_nCost;
		pDestObject->m_lAmount = pSourceObject->m_lAmount;
		pDestObject->m_nFlags = pSourceObject->m_nFlags;
		pDestObject->m_lXP = pSourceObject->m_lXP;
		pDestObject->m_bEnchanted = pSourceObject->m_bEnchanted;

		memcpy(pDestObject->m_nContents, pSourceObject->m_nContents, MAX_OBJECT_CONTENTS*sizeof(int));
		memcpy(pDestObject->m_nContentsCount, pSourceObject->m_nContentsCount, MAX_OBJECT_CONTENTS*sizeof(int));

		pDestObject->m_dwContainerID = pSourceObject->m_dwContainerID;

		pDestObject->m_nContainerPlatinum = pSourceObject->m_nContainerPlatinum;
		pDestObject->m_nContainerGold = pSourceObject->m_nContainerGold;
		pDestObject->m_nContainerElectrum = pSourceObject->m_nContainerElectrum;
		pDestObject->m_nContainerSilver = pSourceObject->m_nContainerSilver;
		pDestObject->m_nContainerCopper = pSourceObject->m_nContainerCopper;
		pDestObject->m_nItemValue = pSourceObject->m_nItemValue;

		memcpy(pDestObject->m_nContentsCount, pSourceObject->m_nContentsCount, MAX_OBJECT_CONTENTS*sizeof(int));

		memcpy(pDestObject->m_szExtendedName, pSourceObject->m_szExtendedName, 128 * sizeof(char)); 

		pDestObject->m_bMysteryItem = pSourceObject->m_bMysteryItem;

		pDestObject->m_nIntelligence = pSourceObject->m_nIntelligence;
		pDestObject->m_Alignment = pSourceObject->m_Alignment;

		memcpy(pDestObject->m_szPrimaryAbility, pSourceObject->m_szPrimaryAbility, 3*128*sizeof(char));
		memcpy(pDestObject->m_szExtraordinaryPower, pSourceObject->m_szExtraordinaryPower, 128*sizeof(char));
		memcpy(pDestObject->m_szSpecialPurpose, pSourceObject->m_szSpecialPurpose, 128*sizeof(char));
		memcpy(pDestObject->m_szSpecialPurposePower, pSourceObject->m_szSpecialPurposePower, 128*sizeof(char));

		pDestObject->m_nCustomFlags = pSourceObject->m_nCustomFlags;
	}

	cDNDObject *Clone()
	{
		cDNDObject *ptr = new cDNDObject();
		CopyTo(ptr);
		return ptr;
	}

	BOOL IsWeaponUsableByClass(DND_CHARACTER_CLASSES nClass)
	{
		switch(nClass)
		{
			case DND_CHARACTER_CLASS_UNDEF:
			{
				return FALSE;
			}
			case DND_CHARACTER_CLASS_FIGHTER:
			case DND_CHARACTER_CLASS_RANGER:
			case DND_CHARACTER_CLASS_CAVALIER:
			case DND_CHARACTER_CLASS_PALADIN:
			case DND_CHARACTER_CLASS_BARBARIAN:
			case DND_CHARACTER_CLASS_ASSASSIN:
			{
				return TRUE;
			}

			case DND_CHARACTER_CLASS_CLERIC:
			{
				int nFlag = (m_nFlags / 100) % 10;

				if(nFlag != 1)
				{
					return FALSE;
				}

				break;
			}

			case DND_CHARACTER_CLASS_DRUID:
			case DND_CHARACTER_CLASS_MONK:
			{
				int nFlag = (m_nFlags / 100) % 10;

				if(nFlag == 0)
				{
					return FALSE;
				}

				break;
			}

			case DND_CHARACTER_CLASS_THIEF:
			case DND_CHARACTER_CLASS_THIEF_ACROBAT:
			{
				int nFlag = (m_nFlags / 10) % 10;

				if(nFlag == 0)
				{
					return FALSE;
				}

				break;
			}

			case DND_CHARACTER_CLASS_MAGE:
			case DND_CHARACTER_CLASS_ILLUSIONIST:
			{
				int nFlag = m_nFlags % 10;

				if(nFlag == 0)
				{
					return FALSE;
				}


				break;
			}
		}

		return TRUE;
	}
};


#define POBJECTTYPE cDNDObject*
typedef CTypedPtrArray <CPtrArray, POBJECTTYPE> POBJECTTYPEARRAYBASE;

class CSafeObjectTypedPtrArray : public POBJECTTYPEARRAYBASE
{

public:

	POBJECTTYPE GetAt(INT_PTR nIndex) const
	{ 
		int nSize = CTypedPtrArray::GetSize();
		if(nIndex >= nSize)
		{
			return NULL;
		}

		return (POBJECTTYPE)CTypedPtrArray::GetAt(nIndex); 
	};

};
typedef CTypedPtrArray <CSafeObjectTypedPtrArray, POBJECTTYPE> POBJECTTYPEARRAY;


class cDNDArmor : public cDNDObject
{
public:

	int m_nArmorClass; 
	int m_nMove;
	int m_nReserved[1024];

	cDNDArmor()
	{
		memset(m_szType, 0, 32 * sizeof(char)); 
		m_ObjectType = DND_OBJECT_TYPE_ARMOR;
		m_nArmorClass = 10; 
		m_nWeight = 0;
		m_nMove = 0;
		memset(m_nReserved, 0, 1024 * sizeof(char));
	}

	~cDNDArmor()
	{
	}

	void CopyTo(cDNDArmor *pDestArmor)
	{
		cDNDArmor *pSourceArmor = this;

		if(pDestArmor == NULL)
		{
			pDestArmor = new cDNDArmor();
		}

		cDNDObject::CopyBase((cDNDObject *)pSourceArmor, (cDNDObject *)pDestArmor);

		pDestArmor->m_nArmorClass = pSourceArmor->m_nArmorClass; 
		pDestArmor->m_nMove = pSourceArmor->m_nMove;
		pDestArmor->m_nMagicAdj = pSourceArmor->m_nMagicAdj;
		pDestArmor->m_lXP = pSourceArmor->m_lXP;
	}

	cDNDArmor *Clone()
	{
		cDNDArmor *ptr = new cDNDArmor();
		CopyTo(ptr);
		return ptr;
	}

	BOOL IsMetalArmor()
	{
		if(m_wTypeId >= 200)
			return TRUE;

		return FALSE;
	}

};

#define PARMORTYPE cDNDArmor*
typedef CTypedPtrMap <CMapWordToPtr, WORD, PARMORTYPE> PARMORTYPEMAP;

//////////////////////////////////////////////////////////

class cDNDShield : public cDNDObject
{
public:

	int m_nReserved[1024];

	cDNDShield()
	{
		memset(m_szType, 0, 32 * sizeof(char)); 
		m_ObjectType = DND_OBJECT_TYPE_SHIELD;
		m_nWeight = 0;
		m_nMagicAdj = 0;
		memset(m_nReserved, 0, 1024 * sizeof(char));
	}

	~cDNDShield()
	{
	}

	void CopyTo(cDNDShield *pDestShield)
	{
		cDNDShield *pSourceShield = this;

		if(pDestShield == NULL)
		{
			pDestShield = new cDNDShield();
		}

		cDNDObject::CopyBase((cDNDObject *)pSourceShield, (cDNDObject *)pDestShield);		
	}

	cDNDShield *Clone()
	{
		cDNDShield *ptr = new cDNDShield();
		CopyTo(ptr);
		return ptr;
	}
};

#define PSHIELDTYPE cDNDShield*
typedef CTypedPtrMap <CMapWordToPtr, WORD, PSHIELDTYPE> PSHIELDTYPEMAP;

//////////////////////////////////////////////////////////

class cDNDRing : public cDNDObject
{
public:

	int m_nReserved[1024];

	cDNDRing()
	{
		memset(m_szType, 0, 32 * sizeof(char)); 
		m_ObjectType = DND_OBJECT_TYPE_RING;
		m_nWeight = 0;
		m_nMagicAdj = 0;
		memset(m_nReserved, 0, 1024 * sizeof(char));
	}

	~cDNDRing()
	{
	}

	void CopyTo(cDNDRing *pDestRing)
	{
		cDNDRing *pSourceRing = this;

		if(pDestRing == NULL)
		{
			pDestRing = new cDNDRing();
		}

		cDNDObject::CopyBase((cDNDObject *)pSourceRing, (cDNDObject *)pDestRing);		
	}

	cDNDRing *Clone()
	{
		cDNDRing *ptr = new cDNDRing();
		CopyTo(ptr);
		return ptr;
	}

	BOOL IsProtectionRing()
	{
		int nFlag = (m_nFlags / 1000) % 10;

		if(nFlag == 1)
			return TRUE;

		return FALSE;
	}

	BOOL IsRegenerationRing()
	{
		int nFlag = (m_nFlags / 100) % 10;

		if(nFlag == 1)
			return TRUE;

		return FALSE;
	}
};

#define PRINGTYPE cDNDRing*
typedef CTypedPtrMap <CMapWordToPtr, WORD, PRINGTYPE> PRINGTYPEMAP;

//////////////////////////////////////////////////////////

class cDNDWeapon : public cDNDObject
{
public:

	char m_szSpaceRange[16];
	char m_szSpeed[12];

	char m_szDamageSmall[16];
	char m_szDamageLarge[16];

	int m_nExceptionalStrength;

	int m_nWeaponVSAC[11];

	int m_nCustomAmmoType;

	int m_nReserved[1022];

	cDNDWeapon()
	{
		Init();
	}

	~cDNDWeapon()
	{
	}

	void Init()
	{
		cDNDObject::Init();

		memset(m_szType, 0, 32 * sizeof(char)); 
		m_ObjectType = DND_OBJECT_TYPE_WEAPON;

		memset(m_szSpaceRange, 0, 16 * sizeof(char)); 
		memset(m_szSpeed, 0, 12 * sizeof(char)); 
		memset(m_szDamageSmall, 0, 16 * sizeof(char)); 
		memset(m_szDamageLarge, 0, 16 * sizeof(char)); 

		m_nExceptionalStrength = 0;

		memset(m_nWeaponVSAC, 0, 11 * sizeof(int)); 
		
		m_nMagicAdj = 0;
		m_nCustomAmmoType = 0;

		memset(m_nReserved, 0, 1022 * sizeof(char));
	}

	void CopyTo(cDNDWeapon *pDestWeapon)
	{
		if(pDestWeapon == NULL)
		{
			pDestWeapon = new cDNDWeapon();
		}

		cDNDWeapon *pSourceWeapon = this;

		cDNDObject::CopyBase((cDNDObject *)pSourceWeapon, (cDNDObject *)pDestWeapon);

		memcpy(pDestWeapon->m_szSpaceRange, pSourceWeapon->m_szSpaceRange, 16 * sizeof(char)); 
		memcpy(pDestWeapon->m_szSpeed, pSourceWeapon->m_szSpeed, 12 * sizeof(char)); 
		memcpy(pDestWeapon->m_szDamageSmall, pSourceWeapon->m_szDamageSmall, 16 * sizeof(char)); 
		memcpy(pDestWeapon->m_szDamageLarge, pSourceWeapon->m_szDamageLarge, 16 * sizeof(char)); 

		memcpy(pDestWeapon->m_nWeaponVSAC, pSourceWeapon->m_nWeaponVSAC, 11 * sizeof(int)); 

		pDestWeapon->m_nCustomAmmoType = pSourceWeapon->m_nCustomAmmoType;

		pDestWeapon->m_nExceptionalStrength = pSourceWeapon->m_nExceptionalStrength;
		pDestWeapon->m_nFlags = pSourceWeapon->m_nFlags;
		pDestWeapon->m_nCustomFlags = pSourceWeapon->m_nCustomFlags;
	}

	void CopyFull(cDNDWeapon *pDestWeapon)
	{
		if(pDestWeapon == NULL)
		{
			pDestWeapon = new cDNDWeapon();
		}

		cDNDWeapon *pSourceWeapon = this;
		memcpy(pDestWeapon, pSourceWeapon, sizeof(cDNDWeapon)); 
	}

	cDNDWeapon *Clone()
	{
		cDNDWeapon *ptr = new cDNDWeapon();
		CopyFull(ptr);
		return ptr;
	}

	int GetMaximumDamage()
	{
		int nRetVal = 0;

		int nLow = 0;
		int nHigh = 0;

		sscanf(this->m_szDamageSmall, "%d-%d", &nLow, &nRetVal);

		sscanf(this->m_szDamageLarge, "%d-%d", &nLow, &nHigh);

		if(nHigh > nRetVal)
			nRetVal = nHigh;

		return nRetVal;
	}

};

#define PWEAPONTYPE cDNDWeapon*
typedef CTypedPtrArray <CPtrArray, PWEAPONTYPE> PWEAPONTYPEARRAY;


#define MAGIC_ITEM_FLAG_ARMOR					0x0001
#define MAGIC_ITEM_FLAG_SWORDS					0x0002
#define MAGIC_ITEM_FLAG_RINGS					0x0004
#define MAGIC_ITEM_FLAG_POTIONS					0x0008
#define MAGIC_ITEM_FLAG_MISC_WEAPONS			0x0010
#define MAGIC_ITEM_FLAG_RODS_STAVES_WANDS		0x0020
#define MAGIC_ITEM_FLAG_MISC_MAGIC_1			0x0040
#define MAGIC_ITEM_FLAG_MISC_MAGIC_2			0x0080
#define MAGIC_ITEM_FLAG_MISC_MAGIC_3			0x0100
#define MAGIC_ITEM_FLAG_MISC_MAGIC_4			0x0200
#define MAGIC_ITEM_FLAG_MISC_MAGIC_5			0x0400
#define MAGIC_ITEM_FLAG_MISC_MAGIC				(MAGIC_ITEM_FLAG_MISC_MAGIC_1 | MAGIC_ITEM_FLAG_MISC_MAGIC_2 | MAGIC_ITEM_FLAG_MISC_MAGIC_3 | MAGIC_ITEM_FLAG_MISC_MAGIC_4 | MAGIC_ITEM_FLAG_MISC_MAGIC_5)
#define MAGIC_ITEM_FLAG_SCROLLS					0x0800
#define MAGIC_ITEM_FLAG_ARTIFACTS_RELICS		0x1000

#define MAGIC_ITEM_FLAG_ANY						0x0FFF

typedef enum
{
	DND_MAGIC_ITEM_TABLE_UNDEF = 0,

	DND_MAGIC_ITEM_TABLE_POTIONS,
	DND_MAGIC_ITEM_TABLE_RINGS,
	DND_MAGIC_ITEM_TABLE_SCROLLS,
	DND_MAGIC_ITEM_TABLE_RODS_STAVES_WANDS,
	DND_MAGIC_ITEM_TABLE_MISC_MAGIC_1,
	DND_MAGIC_ITEM_TABLE_MISC_MAGIC_2,
	DND_MAGIC_ITEM_TABLE_MISC_MAGIC_3,
	DND_MAGIC_ITEM_TABLE_MISC_MAGIC_4,
	DND_MAGIC_ITEM_TABLE_MISC_MAGIC_5,
	DND_MAGIC_ITEM_TABLE_MISC_MAGIC_SPECIAL,
	DND_MAGIC_ITEM_TABLE_ARMOR,
	DND_MAGIC_ITEM_TABLE_SWORDS,

	DND_MAGIC_ITEM_TABLE_MISC_WEAPONS,
	
	DND_MAGIC_ITEM_TABLE_LAST_TYPE,

} DND_MAGIC_ITEM_TABLE_TYPES;


class cDNDMagicTableItem 
{
public:

	DND_MAGIC_ITEM_TABLE_TYPES m_nTable; 
	int m_nRollLow;
	int m_nRollHigh;

	char m_szDesc[128];

	long m_lXPValue;
	long m_lGPValue;

	int m_nAmountLow;
	int m_nAmountHigh;


	int m_nMundanes;
	char m_szMundaneName[10][32];
	cDNDObject *m_pMundaneObject[10];
	int m_nMagicAdjustmentLow;
	int m_nMagicAdjustmentHigh;

	int m_nLevelLow[2];
	int m_nLevelHigh[2];

	int m_nSpellIndex[MAX_OBJECT_CONTENTS];
	int m_nSpellUsageCharges[MAX_OBJECT_CONTENTS];

	int m_nChargesLow;
	int m_nChargesHigh;

	int m_nEncumbranceOverride;

	int m_nReserved[1023];


	cDNDMagicTableItem()
	{
		m_nTable = DND_MAGIC_ITEM_TABLE_UNDEF; 
		m_nRollLow = 0;
		m_nRollHigh = 0;

		memset(m_szDesc, 0, 128*sizeof(char));

		m_lXPValue = 0L;
		m_lGPValue = 0L;

		m_nAmountLow = 0;
		m_nAmountHigh = 0;


		m_nMundanes = 0;

		for(int i = 0; i < 10; ++i)
		{
			memset(m_szMundaneName[i], 0, 32*sizeof(char));
			m_pMundaneObject[i] = NULL;
		}

		m_nMagicAdjustmentLow = 0;
		m_nMagicAdjustmentHigh = 0;

		memset(m_nLevelLow, 0, 2*sizeof(int));
		memset(m_nLevelHigh, 0, 2*sizeof(int));

		memset(m_nSpellIndex, 0, MAX_OBJECT_CONTENTS*sizeof(int));
		memset(m_nSpellUsageCharges, 0, MAX_OBJECT_CONTENTS*sizeof(int));

		m_nChargesLow = 0;
		m_nChargesHigh = 0;

		m_nEncumbranceOverride = 0;

		memset(m_nReserved, 0, 1023*sizeof(int));
	};

	~cDNDMagicTableItem()
	{
	};

	POBJECTTYPE EnchantItem(int nMundane, int nMagicAdjustment, int nAmount);

	void PopulateRandomScroll(POBJECTTYPE pObj);
	void PopulateMagicSword(POBJECTTYPE pObj);
	void PopulateRandomMagicItem(POBJECTTYPE pObj);
	void ValidateMagicItemName(POBJECTTYPE pObj);

};

#define PMAGICTABLEITEM cDNDMagicTableItem*
typedef CTypedPtrArray <CPtrArray, PMAGICTABLEITEM> PMAGICTABLEITEMARRAY;


class cDNDMagicItemDescription
{
public:

	CString m_szMagicItemName;
	CString m_szDescription;

	cDNDMagicItemDescription()
	{
		m_szMagicItemName = _T("");
		m_szDescription = _T("");
	}

	~cDNDMagicItemDescription()
	{
	}

};

#define PMAGICITEMDESCRIPTION cDNDMagicItemDescription*
typedef CTypedPtrMap <CMapStringToPtr, CString, PMAGICITEMDESCRIPTION> PMAGICITEMDESCRIPTIONMAP;

#define MAX_SPELL_LEVELS 10  // 0-9 includes cantrips at 0
#define MAX_SPELLS_PER_LEVEL 128
#define MAX_SPELL_DESC_SIZE	1024*5

class cDNDSpell
{
public:

	DND_CHARACTER_CLASSES m_ClassBook;
	int m_nSpellIdentifier;
	BOOL m_bSpellValid;
	int m_nSpellLevel;
	int m_nSpellNumber;
	char m_szSpellName[64];
	char m_szSpellType[64];
	char m_szSpellComponents[32];
	char m_szSpellRange[32];
	char m_szSpellCastingTime[32];
	char m_szSpellDuration[32];
	char m_szSpellSavingThrow[32];
	char m_szSpellAreaOfEffect[64];

	char m_szSpellDesc[MAX_SPELL_DESC_SIZE];

	cDNDSpell()
	{
		Init();
	}

	~cDNDSpell()
	{
	}

	void Init()
	{
		m_ClassBook = DND_CHARACTER_CLASS_UNDEF;
		m_nSpellIdentifier = 0;
		m_bSpellValid = FALSE;
		m_nSpellLevel = 0;
		m_nSpellNumber = -1;
		memset(m_szSpellName, 0, 64 * sizeof(char));
		memset(m_szSpellType, 0, 64 * sizeof(char));
		memset(m_szSpellComponents, 0, 32 * sizeof(char));
		memset(m_szSpellRange, 0, 32 * sizeof(char));
		memset(m_szSpellCastingTime, 0, 32 * sizeof(char));
		memset(m_szSpellDuration, 0, 32 * sizeof(char));
		memset(m_szSpellSavingThrow, 0, 32 * sizeof(char));
		memset(m_szSpellAreaOfEffect, 0, 64 * sizeof(char));
		memset(m_szSpellDesc, 0, MAX_SPELL_DESC_SIZE * sizeof(char));
	}


};

#define PSPELL cDNDSpell*
typedef CTypedPtrArray <CPtrArray, PSPELL> PSPELLARRAY;

//////////////////////////////////////////////////////////

class cDNDSpellBook
{
public:

	DND_CHARACTER_CLASSES m_ClassBook;
	int m_nMaxLevel;

	cDNDSpell m_Spells[MAX_SPELL_LEVELS][MAX_SPELLS_PER_LEVEL]; 
	int m_nSpellsPerLevel[MAX_SPELL_LEVELS];

	cDNDSpellBook()
	{
		m_ClassBook = DND_CHARACTER_CLASS_UNDEF;
		m_nMaxLevel = 0;

		memset(m_nSpellsPerLevel, 0, MAX_SPELL_LEVELS*sizeof(int));
	}

	~cDNDSpellBook()
	{
	}


};

#define PSPELLBOOK cDNDSpellBook*
typedef CTypedPtrArray <CPtrArray, PSPELLBOOK> PSPELLBOOKARRAY;


//////////////////////////////////////////////////////////

class cDNDSpellSlot
{
public:

	cDNDSpell *m_pSpell;
	int *m_pnMemorizedSlot;
	int m_nChargesExpended;

	cDNDSpellSlot()
	{
		m_pSpell = NULL;
		m_pnMemorizedSlot = NULL;
		m_nChargesExpended = 0;
	}

	cDNDSpellSlot(cDNDSpell *_pSpell, int *_pnMemorizedSlot, int nChargesExpended)
	{
		m_pSpell = _pSpell;
		m_pnMemorizedSlot = _pnMemorizedSlot;
		m_nChargesExpended = nChargesExpended;
	}

	~cDNDSpellSlot()
	{
	}

};

#define PSPELLSLOT cDNDSpellSlot*

//////////////////////////////////////////////////////////


typedef enum
{
	DND_LANGUAGE_NONE =		 0,
	DND_LANGUAGE_COMMON	=	 1,

	DND_LANGUAGE_DWARVISH = 16,
	DND_LANGUAGE_ELVISH	=	17,
	DND_LANGUAGE_GOBLIN =	26,
	DND_LANGUAGE_GNOLL =	27,
	DND_LANGUAGE_GNOME =	28,
	DND_LANGUAGE_HALFLING = 29,
	DND_LANGUAGE_HOBGOBLIN = 30,
	DND_LANGUAGE_KOBOLD =	31,
	DND_LANGUAGE_ORCISH =	44,
	DND_LANGUAGE_UNDERCOMMON =	55

} DND_LANGUAGES;

class cDNDLanguage
{
public:

	int m_nDieRollLow;
	int m_nDieRollHigh;

	int m_nIndex;

	int m_nList;

	CString m_szLanguageName;

	cDNDLanguage()
	{
		m_nDieRollLow = 0;
		m_nDieRollHigh = 0;

		m_nIndex = 0;

		m_nList = 0;

		m_szLanguageName = _T("");
	}

	~cDNDLanguage()
	{
		
	}

};

#define PDNDLANGUAGE cDNDLanguage*
typedef CTypedPtrArray <CPtrArray, PDNDLANGUAGE> PDNDLANGUAGEARRAY;



class cDNDCharacter
{
public:

	UINT	m_Version;

	DWORD m_dwCharacterID;
	char m_szPortraitPath[MAX_PATH];

	char m_szCharacterName[128];

	DND_CHARACTER_RACES			m_nRace;
	DND_CHARACTER_CLASSES		m_Class[4];
	int							m_nLevel[4];
	LONG						m_lExperience[4];
	int							m_nSex;
	DND_CHARACTER_ALIGNMENTS	m_nAlignment;

	int m_nBaseStats[8];
	int m_nDisplayStats[8];
	int m_nEditedStats[8];

	int m_nHitPoints;
	int m_nCurrentDamage;
	int m_nHitPointRolls[4][20];

	cDNDArmor m_ArmorWorn;
	cDNDShield m_ShieldWorn;

	int m_nCurrentArmorClass;
	int m_nUnshieldedArmorClass;
	int m_nRearArmorClass;

	cDNDWeapon m_SelectedWeapons[4];
	cDNDWeapon m_SelectedAmmo;

	LONG m_lCopperCarried;
	LONG m_lSilverCarried;
	LONG m_lElectrumCarried;
	LONG m_lGoldCarried;
	LONG m_lPlatinumCarried;

	cDNDObject m_Inventory[MAX_CHARACTER_INVENTORY];
	cDNDObject m_WeaponProficiencies[MAX_WEAPON_PROFICIENCIES];

	LONG m_lEarnedXP;	// current earned XP
	BOOL m_bIsHenchman;  // not the same thing as being an NPC, an NPC is a monster from the Monster Manual, not a character
	int m_nDualClassClass;  // class index that a DUAL classed (human) character is earning XP - not the same thing as multi-classed

	int m_nXPValue;	// XP awarded for killing this character, if 0 the program will attempt to calculate it 

	DWORD m_dwSubPartyID;

	int m_nLanguages[MAX_CHARACTER_LANGUAGES];

	BOOL m_bPocketPC;	//this is an NPC created in a random party, and should be saved IN that party

	int m_nWeaponlessCombatAdjustments[3][3];

	DND_CHARACTER_VISION_TYPES m_VisionType;

	BOOL m_bKeenEar;
	BOOL m_bVeryKeenEar;

	char m_szSecondarySkill[64];

	int m_nConcealedMove;
	int m_nClimbingMove;
	int m_nSpecialMove;


	int m_nReserved_0[971];

	DND_CHARACTER_CLASSES		m_SpellClasses[4];
	int m_nCastingLevels[4];
	int m_nSpellBooks[4][MAX_SPELL_LEVELS][MAX_SPELLS_PER_LEVEL];
	int m_nSpellsMemorized[4][MAX_SPELL_LEVELS][MAX_SPELLS_PER_LEVEL];
	int m_nLastSpellsMemorized[4][MAX_SPELL_LEVELS][MAX_SPELLS_PER_LEVEL];

	float m_fMapLocationX;
	float m_fMapLocationY;

	float m_fLocalLocationX;
	float m_fLocalLocationY;

	cDNDRing m_RingsWorn[2];

	BOOL m_bIsNPC;
	BOOL m_bIsCache;

	///////////////////////////////////
	// Character Details 460 bytes
	//////////////////////////////////

	char m_szPlayerName[32];
	char m_szDateCreated[16];
	char m_szPatronDeity[32];
	char m_szPlaceofOrigin[32];
	char m_szReligion[32];
	int m_nHeight;
	int m_nWeight;
	int m_nDOBMonth;
	int m_nDOBDay;
	int m_nDOBYear;
	int m_nAge;
	int m_nAgeAdj;
	char m_szHairColor[16];
	char m_szEyeColor[16];
	char m_szWill[256];

	cDNDObject m_HelmWorn;

	unsigned long m_lSaveFlag;
	unsigned long m_lSavedFlag;

	char m_szDetails[2048];

	char m_szIconPath[MAX_PATH];

	int m_nReserved_1[6453];  // remember to divide by 4 dummy was 6518 before IconPath

	cDNDCharacter()
	{
		m_Version = DMH_CURRENT_VERSION;

		m_dwCharacterID = 0L;
		memset(m_szPortraitPath, 0 , MAX_PATH * sizeof(char));
		memset(m_szCharacterName, 0 , 128 * sizeof(char));

		m_Class[0] = DND_CHARACTER_CLASS_UNDEF;
		m_Class[1] = DND_CHARACTER_CLASS_UNDEF;
		m_Class[2] = DND_CHARACTER_CLASS_UNDEF;
		m_Class[3] = DND_CHARACTER_CLASS_UNDEF;

		m_nLevel[0] = 0;
		m_nLevel[1] = 0;
		m_nLevel[2] = 0;
		m_nLevel[3] = 0;

		m_lExperience[0] = 0L;
		m_lExperience[1] = 0L;
		m_lExperience[2] = 0L;
		m_lExperience[3] = 0L;

		m_nRace = DND_CHARACTER_RACES_UNDEF;
		m_nSex = 0;
		m_nAlignment = DND_CHARACTER_ALIGNMENT_UNDEF;

		m_nBaseStats[0] = 3;
		m_nBaseStats[1] = 3;
		m_nBaseStats[2] = 3;
		m_nBaseStats[3] = 3;
		m_nBaseStats[4] = 3;
		m_nBaseStats[5] = 3;
		m_nBaseStats[6] = 3;
		m_nBaseStats[7] = 0;

		m_nDisplayStats[0] = 3;
		m_nDisplayStats[1] = 3;
		m_nDisplayStats[2] = 3;
		m_nDisplayStats[3] = 3;
		m_nDisplayStats[4] = 3;
		m_nDisplayStats[5] = 3;
		m_nDisplayStats[6] = 3;
		m_nDisplayStats[7] = 0;

		m_nEditedStats[0] = 0;
		m_nEditedStats[1] = 0;
		m_nEditedStats[2] = 0;
		m_nEditedStats[3] = 0;
		m_nEditedStats[4] = 0;
		m_nEditedStats[5] = 0;
		m_nEditedStats[6] = 0;
		m_nEditedStats[7] = 0;

		m_nHitPoints = 0;
		m_nCurrentDamage = 0;
		memset(m_nHitPointRolls,0,4*20*sizeof(int));

		m_nCurrentArmorClass = 10;
		m_nUnshieldedArmorClass = 10;
		m_nRearArmorClass = 10;

		m_lCopperCarried = 0L;
		m_lSilverCarried = 0L;
		m_lElectrumCarried = 0L;
		m_lGoldCarried = 0L;
		m_lPlatinumCarried = 0L;

		m_lEarnedXP = 0L;
		m_bIsHenchman = FALSE;
		m_nDualClassClass = 0;

		m_nXPValue = 0;

		memset(m_nLanguages,0,MAX_CHARACTER_LANGUAGES*sizeof(int));

		m_bPocketPC = FALSE;

		memset(m_nWeaponlessCombatAdjustments,0,9*sizeof(int));

		m_VisionType = DND_CHARACTER_VISION_UNDEF;

		m_bKeenEar = FALSE;
		m_bVeryKeenEar = FALSE;

		memset(m_szSecondarySkill, 0, 64 * sizeof(char));

		m_nConcealedMove = 0;
		m_nClimbingMove = 0;
		m_nSpecialMove = 0;

		memset(m_nReserved_0,0,971*sizeof(int));

		m_SpellClasses[0] = DND_CHARACTER_CLASS_UNDEF;
		m_SpellClasses[1] = DND_CHARACTER_CLASS_UNDEF;
		m_SpellClasses[2] = DND_CHARACTER_CLASS_UNDEF;
		m_SpellClasses[3] = DND_CHARACTER_CLASS_UNDEF;

		memset(m_nCastingLevels, 0, 4*sizeof(int));


		memset(m_nSpellBooks, 0, 4*MAX_SPELL_LEVELS*MAX_SPELLS_PER_LEVEL*sizeof(int));
		memset(m_nSpellsMemorized, 0, 4*MAX_SPELL_LEVELS*MAX_SPELLS_PER_LEVEL*sizeof(int));
		memset(m_nLastSpellsMemorized, 0, 4*MAX_SPELL_LEVELS*MAX_SPELLS_PER_LEVEL*sizeof(int));

		m_fMapLocationX = 0.0f;
		m_fMapLocationY = 0.0f;

		m_fLocalLocationX = 0.0f;
		m_fLocalLocationY = 0.0f;

		m_bIsNPC = FALSE;
		m_bIsCache = FALSE;

		memset(m_szPlayerName, 0, 32 * sizeof(char));
		memset(m_szDateCreated, 0, 16 * sizeof(char));
		memset(m_szPatronDeity, 0, 32 * sizeof(char));
		memset(m_szPlaceofOrigin, 0, 32 * sizeof(char));
		memset(m_szReligion, 0, 32 * sizeof(char));
		m_nHeight = 0;
		m_nWeight = 0;
		m_nDOBMonth = 0;
		m_nDOBDay = 0;
		m_nDOBYear = 0;
		m_nAge = 0;
		m_nAgeAdj = 0;
		memset(m_szHairColor, 0, 16 * sizeof(char));
		memset(m_szEyeColor, 0, 16 * sizeof(char));
		memset(m_szWill, 0,256 * sizeof(char));

		m_lSaveFlag = 0L;
		m_lSavedFlag = 0L;

		memset(m_szDetails, 0, 2048*sizeof(char));

		memset(m_szIconPath, 0, MAX_PATH *sizeof(char));

		memset(m_nReserved_1,0,6453*sizeof(int));

	}

	~cDNDCharacter()
	{
	}

	void ValidateInventory();
	void StackInventory();
	void ValidateInventoryFlags();
	void ValidateMagicContainerInventory();
	LONG CountContainerCoins(DND_COIN_TYPES nCoinType);
	void BalanceContainerCoins(POBJECTTYPE pBaseContainer, DND_COIN_TYPES nCoinType);
	BOOL AddToInventory(cDNDObject *pNewObject, int *nReturnSlot = NULL);
	BOOL AddToInventoryFull(cDNDObject *pNewObject);
	BOOL BuyItem(int nCost);
	cDNDObject *FindObjectInInventory(DWORD dwID);
	BOOL ObjectIsInContainer(cDNDObject *pObj, DWORD dwParentContainerID, int nLevel);
	int CountObjectsInContainer(cDNDObject *pObj);
	BOOL InventorySlotIsInBagOfHolding(POBJECTTYPE pObject, int nLevel);
	int GetInventoryOpenSlots();
	BOOL IsEquippingObject(POBJECTTYPE pObject);
	void ValidateLanguages();
	BOOL CanSpeakLanguage(DND_LANGUAGES nLanguage);
	int GetWeaponSpecializationLevel();

	void ValidateProficiencies();
	void AddWeaponProficiency(PWEAPONTYPE pWeapon);
	BOOL IsProficientWithWeapon(PWEAPONTYPE pWeapon, int *nSpecializedToHitBonus, int *nSpecializedDamageBonus);
	char *GetUnarmedDamageDesc();
	void LockAndLoad();

	BOOL CastSpell(cDNDSpellSlot *pSpellSlot);
	BOOL EatRations();

	BOOL IsAlive();
	void MarkChanged();
	void MarkSaved();
	BOOL IsChanged();

};

#define PDNDCHARACTER cDNDCharacter*

DND_CHARACTER_VISION_TYPES GetCharacterVision(cDNDCharacter *pCharacter);
int GetCharacterListeningScore(cDNDCharacter *pCharacter);

//////////////////////////////////////////////////////////

class cDNDMonsterManualEntry 
{
public:

	int	m_nMonsterIndex;
	int	m_nMonsterID;
	CString m_szMMName;						// Orc,
	CString m_szType;            			// Humanoid,
	CString m_szFrequency;       			// Common,
	CString m_szIntelligence;    			// Low to Average (5-10),
	CString m_szPercentinLair;				// 0.35,
	CString m_szTreasureType;				// L (C,O,Qx10,S),
	DND_CHARACTER_ALIGNMENTS m_nAlignment;  // LE,
	CString m_szNumAppearing;   			// 30-300,
	int m_nBaseAC;							// 6,
	CString m_szMovement;        			// 9,
	CString m_szHD;              			// 1,
	CString m_szNumAttacks;     			// 1,
	CString m_szDamage;          			// 1-8 or by weapon,
	CString m_szSpecialAttack;  			// Nil,
	CString m_szSpecialDefense; 			// Nil,
	CString m_szMagicResist;				// Standard,
	CString m_szSize;            			// M (6'+),
	CString m_szPsionicAbility; 			// Nil,
	CString m_szAttDefModes;       			// Nil,
	CString m_szXP;		    				// 10+1/hp,
	CString m_szArmors;
	CString m_szWeapons;
	CString m_szBook;						//MM, MM2, FF etc.

	cDNDMonsterManualEntry()
	{
		Init();
	}

	~cDNDMonsterManualEntry()
	{
	}

	void Init()
	{
		m_nMonsterIndex		= 0;
		m_nMonsterID		= 0;
		m_szMMName			= _T("");  	
		m_szType        	= _T("");  	
		m_szFrequency		= _T("");         	
		m_szIntelligence	= _T("");      	
		m_szPercentinLair	= _T("");        
		m_szTreasureType	= _T("");         
		m_nAlignment		= DND_CHARACTER_ALIGNMENT_UNDEF;     	
		m_szNumAppearing	= _T("");     	
		m_nBaseAC			= 10;  
		m_szMovement		= _T("");          	
		m_szHD				= _T("");                	       	
		m_szNumAttacks		= _T("");       	
		m_szDamage			= _T("");            	
		m_szSpecialAttack	= _T("");    	
		m_szSpecialDefense	= _T("");   	
		m_szMagicResist		= _T("");          
		m_szSize			= _T("");              	
		m_szPsionicAbility	= _T("");   	
		m_szAttDefModes		= _T("");   
		m_szXP				= _T("");   
		m_szArmors			= _T("");   
		m_szWeapons			= _T("");   
		m_szBook			= _T("");
	}

	void CopyFrom(cDNDMonsterManualEntry* pMonster)
	{
		m_nMonsterIndex		= pMonster->m_nMonsterIndex;	
		m_nMonsterID		= pMonster->m_nMonsterID;		
		m_szMMName			= pMonster->m_szMMName;			
		m_szType        	= pMonster->m_szType;        	
		m_szFrequency		= pMonster->m_szFrequency;		
		m_szIntelligence	= pMonster->m_szIntelligence;	
		m_szPercentinLair	= pMonster->m_szPercentinLair;	
		m_szTreasureType	= pMonster->m_szTreasureType;	
		m_nAlignment		= pMonster->m_nAlignment;		    	
		m_szNumAppearing	= pMonster->m_szNumAppearing;	
		m_nBaseAC			= pMonster->m_nBaseAC;			
		m_szMovement		= pMonster->m_szMovement;		
		m_szHD				= pMonster->m_szHD;				  	
		m_szNumAttacks		= pMonster->m_szNumAttacks;		
		m_szDamage			= pMonster->m_szDamage;			
		m_szSpecialAttack	= pMonster->m_szSpecialAttack;	
		m_szSpecialDefense	= pMonster->m_szSpecialDefense;	
		m_szMagicResist		= pMonster->m_szMagicResist;		
		m_szSize			= pMonster->m_szSize;			
		m_szPsionicAbility	= pMonster->m_szPsionicAbility;	
		m_szAttDefModes		= pMonster->m_szAttDefModes;		
		m_szXP				= pMonster->m_szXP;				
		m_szArmors			= pMonster->m_szArmors;			
		m_szWeapons			= pMonster->m_szWeapons;
		m_szBook			= pMonster->m_szBook;
	}

};




#define PDNDMONSTERMANUALENTRY cDNDMonsterManualEntry*
#if 0
typedef CTypedPtrMap <CMapWordToPtr, WORD, PDNDMONSTERMANUALENTRY> PMONSTERMANUALMAPBASE;

class CMonsterManualMapWordToPtr : public PMONSTERMANUALMAPBASE
{

public:
		CMonsterManualMapWordToPtr(INT_PTR nBlockSize = 10)
		: CTypedPtrMap(nBlockSize) { }



};
typedef CTypedPtrMap <CMonsterManualMapWordToPtr, WORD, PDNDMONSTERMANUALENTRY> PMONSTERMANUALMAP;
#else
typedef CTypedPtrMap <CMapWordToPtr, WORD, PDNDMONSTERMANUALENTRY> PMONSTERMANUALMAP;
#endif


typedef CTypedPtrArray <CPtrArray, PDNDMONSTERMANUALENTRY> PMONSTERMANUALARRAY;

WORD GetMinMapKey(CMapWordToPtr *pMap);
WORD GetMaxMapKey(CMapWordToPtr *pMap);


//////////////////////////////////////////////////////////

class cDNDRandomEncounterIndex 
{
public:

	int m_nLevel;
	int m_nDieRoll;

	CString m_szTableName;

	cDNDRandomEncounterIndex()
	{
		m_nLevel = 0;
		m_nDieRoll = 0;

		m_szTableName = _T("");
	}

	~cDNDRandomEncounterIndex()
	{
	}
};

#define PDNDRANDOMENCOUNTERINDEX cDNDRandomEncounterIndex*

//typedef CTypedPtrMap <CMapWordToPtr, WORD, PDNDRANDOMENCOUNTERINDEX> PRANDOMENCOUNTERINDEXMAP;
//typedef CTypedPtrArray <CPtrArray, PDNDRANDOMENCOUNTERINDEX> PRANOMENCOUNTERINDEXARRAY;

class cDNDRandomEncounterTable;		// forward definition

class cDNDRandomEncounterTableEntry
{
public:

	int m_nDieRollLow[8];
	int m_nDieRollHigh[8];

	CString m_szMonsterName;

	int m_nNumAppearingLow;
	int m_nNumAppearingHigh;

	CString m_szData;

	int m_nNumGenerated;
	int m_nHDOverRide[2];

	PDNDMONSTERMANUALENTRY m_pMonsterManualEntry;

	cDNDRandomEncounterTable *m_pSubTable;

	cDNDRandomEncounterTableEntry()
	{
		memset(m_nDieRollLow, 0, 8*sizeof(int)); 
		memset(m_nDieRollHigh, 0, 8*sizeof(int)); 

		m_szMonsterName = _T("");

		m_nNumAppearingLow = 0;
		m_nNumAppearingHigh = 0;

		m_szData = _T("");

		m_nNumGenerated = 0;

		m_nHDOverRide[0] = 0;
		m_nHDOverRide[1] = 0;

		m_pMonsterManualEntry = NULL;

		m_pSubTable = NULL;
	}

	~cDNDRandomEncounterTableEntry()
	{
	}
};

#define PDNDRANDOMENCOUNTERENTRY cDNDRandomEncounterTableEntry*

typedef CTypedPtrArray <CPtrArray, PDNDRANDOMENCOUNTERENTRY> PRANOMENCOUNTERENTRYARRAY;

class cDNDRandomEncounterTable
{
public:

	CString m_szTableName;

	int m_nLevel;
	int m_nEntries;

	BOOL m_bValidColumn[8];


	PRANOMENCOUNTERENTRYARRAY m_EncounterArray;

	cDNDRandomEncounterTable()
	{
		m_szTableName = _T("");

		m_nLevel = 0;
		m_nEntries = 0;

		memset(m_bValidColumn, 0, 8*sizeof(BOOL)); 
	}

	~cDNDRandomEncounterTable()
	{
		for(int i = 0; i < m_EncounterArray.GetCount(); ++i)
		{
			cDNDRandomEncounterTableEntry *pEntry = m_EncounterArray.GetAt(i);

			if(pEntry != NULL)
			{
				delete pEntry;
			}
		}
	}

	cDNDRandomEncounterTableEntry *GetEntryFromDieRoll(int nDieRoll, int nTerrain)
	{
		cDNDRandomEncounterTable *pTable = this;

		#ifdef _DEBUG
		int nOriginalDieRoll = nDieRoll; // for debugging purposes
		int nOriginalCount = pTable->m_EncounterArray.GetCount();
		int nCount = nOriginalCount;
		#endif

		for(int i = 0; i < pTable->m_EncounterArray.GetCount(); ++i)
		{
			cDNDRandomEncounterTableEntry *pEntry = pTable->m_EncounterArray.GetAt(i);

			if(pEntry != NULL)
			{
				if(nDieRoll >= pEntry->m_nDieRollLow[nTerrain] && nDieRoll <= pEntry->m_nDieRollHigh[nTerrain])
				{
					if(pEntry->m_pSubTable != NULL)
					{
						/*
						i = 0;
						pTable = pEntry->m_pSubTable;
						nDieRoll = RollD100(); // reroll for next table;

						#ifdef _DEBUG
						nCount = pTable->m_EncounterArray.GetCount();
						#endif

						continue;*/
						
						//go recursive on this bitch
						nDieRoll = RollD100(); // reroll for next table;
						return pEntry->m_pSubTable->GetEntryFromDieRoll(nDieRoll, nTerrain);

					}

					return pEntry;
				}
			}
		}

		//should never get here
		cDNDRandomEncounterTableEntry *pEntry = m_EncounterArray.GetAt(0);
		return pEntry;
	}

	
};

#define PDNDRANDOMENCOUNTERTABLE cDNDRandomEncounterTable*

typedef CTypedPtrArray <CPtrArray, PDNDRANDOMENCOUNTERTABLE> PRANOMENCOUNTERTABLEARRAY;

//////////////////////////////////////////////////////////

class cDNDNonPlayerCharacter : public cDNDCharacter
{
public:

	DWORD	m_dwPartyID;
	BOOL	m_bRolled;

	int							m_nMonsterIndex;
	int							m_nHitDice;
	int							m_nHitDicePlus;
	BOOL						m_bPresetHitpoints;

	int							m_nNPCXPValue;	//XP awarded for killing this NPC

	int							m_nDungeonLevel;

	int m_nReserved_0[1019];

	cDNDNonPlayerCharacter()
	{
		m_dwPartyID = 0;

		m_bRolled = FALSE;

		m_bIsNPC = TRUE;

		m_nHitDice = 0;
		m_nHitDicePlus = 0;

		m_bPresetHitpoints = FALSE;

		m_nNPCXPValue = 0;

		m_bIsCache = FALSE;

		//memset(m_nHitDiceRolls, 0, 20 * sizeof(int));

		m_nMonsterIndex = -1;

		m_Class[0] = DND_CHARACTER_CLASS_MONSTER;

		m_nDungeonLevel = 0;

		memset(m_nReserved_0,0,1019*sizeof(int));
	}

	~cDNDNonPlayerCharacter()
	{
	}

	BOOL CalculateNPCHitDice(PDNDMONSTERMANUALENTRY pMonster);
	int CalculateCombatLevel();

};

#define PDNDNONPLAYERCHARACTER cDNDNonPlayerCharacter*


BOOL CharacterIsFighter(cDNDCharacter *pCharacter);
int GetFighterClass(cDNDCharacter *pCharacter);

BOOL CharacterIsMage(cDNDCharacter *pCharacter);
BOOL CharacterIsCleric(cDNDCharacter *pCharacter, BOOL bStrict);
BOOL CharacterIsThief(cDNDCharacter *pCharacter);

BOOL ClassIsValidMultiClass(DND_CHARACTER_CLASSES nClass1, DND_CHARACTER_CLASSES nClass2);
BOOL ClassIsValidDualClass(DND_CHARACTER_CLASSES nClass1, DND_CHARACTER_CLASSES nClass2, DND_CHARACTER_CLASSES nClass3);

int GetHitDieTypeByClass(DND_CHARACTER_CLASSES nClass);
int GetMaxHitDiceByClass(DND_CHARACTER_CLASSES nClass, int *nAdditionalHP);

void GetMinimumStatsByClass(cDNDCharacter *pCharacter, int *nMinStats);

void AddStatModifiersByRace(cDNDCharacter *pCharacter, int *nStatBonus);

BOOL GrantCharacterEarnedExperience(cDNDCharacter *pCharacter);
int GetExperienceLevelByClass(cDNDCharacter *pCharacter, int nClass);
LONG GetExperiencePointsForLevelByClass(DND_CHARACTER_CLASSES nClass, int nLevel);
int CalculateLevelLimits(cDNDCharacter *pCharacter, DND_CHARACTER_CLASSES nClass);

int CalculateSTRAdjustments(cDNDCharacter *pCharacter, int *pnDamAdj, int *pnWeightAllow, int *pnOpenDoors, int *pnBendBars);
int CalculateINTAdjustments(cDNDCharacter *pCharacter, int *pnKnowSpell, int *pnMinSpells, int *pnMaxSpells);
int CalculateWISAdjustments(cDNDCharacter *pCharacter,  char **pszSpellBonus, int *pnSpellFailure);
int CalculateDEXAdjustments(cDNDCharacter *pCharacter, int *pnDefenseAdj);
int CalculateCONAdjustments(cDNDCharacter *pCharacter, int *pnSysShock, int *pnResSurvival);
int CalculateCHAAdjustments(cDNDCharacter *pCharacter, int *pnLoyaltyBase, int *pnReactAdj);

void GetToHitChart(cDNDCharacter *pCharacter, int *pnAttackMatrix);
void GetSavingThrows(cDNDCharacter *pCharacter, int *pnSaveMatrix);

BOOL GetTurnUndeadMatrix(cDNDCharacter *pCharacter, int *pnTurnMatrix);

void GetThiefSkills(cDNDCharacter *pCharacter, float *pfThiefSkillMatrix);
int GetAssassinationTable(cDNDCharacter *pCharacter, int *pnAssassinationMatrix);

int GetScrollSpellFailureChance(cDNDCharacter *pCharacter, POBJECTTYPE pScroll, int _nSpellLevel, int *pnTotalFailure, int *pnReversed);
int GetLevelCanCastSpell(cDNDCharacter *pCharacter, DND_CHARACTER_CLASSES _nSpellClass, int _nSpellLevel, int *pnCastingLevel);
int GetSpellLevels(cDNDCharacter *pCharacter, DND_CHARACTER_CLASSES _nSpellClass, int _nCastLevel, int _nSpellLevel);

int CalculateExperienceBonus(cDNDCharacter *pCharacter, int nClass = -1, int *pnNumClasses = NULL);
int CalculateEncumbrance(cDNDCharacter *pCharacter, int *pnMaxWeight);
int IsMonkClass(cDNDCharacter *pCharacter);
char * GetMonkWeaponDamageAdj(cDNDCharacter *pCharacter, int nWeaponSlot);
int CalculateBaseArmorClass(cDNDCharacter *pCharacter);
int CalculateBaseMovement(cDNDCharacter *pCharacter);
char *CalculateAttacksPerRound(cDNDCharacter *pCharacter, BOOL bBase = FALSE);
DND_CHARACTER_CLASSES GetCombatClass(cDNDCharacter *pCharacter, int *pnCombatLevel);
int CalculateWeaponProficiencies(cDNDCharacter *pCharacter, int *pnProfPenalty);
void CalculateWeaponlessCombatMatrix(cDNDCharacter *pCharacter);

BOOL GetSpellClasses(cDNDCharacter *pCharacter);
int CountSpellsInLevel(int *pnArray);
int CountSpellsInLevel(cDNDCharacter *pCharacter, DND_CHARACTER_CLASSES _nSpellClass, int _nSpellLevel);

void GenerateHeightWeight(cDNDCharacter *pCharacter);
int GenerateCharacterAge(cDNDCharacter *pCharacter);

int GetPriceFromString(char *szPrice);
char *GetStringFromPrice(int nPrice);

int GetObjectFlag(PWEAPONTYPE pWeapon, int nFlag);
void SetObjectFlag(PWEAPONTYPE pWeapon, int nFlag, int nValue);

int GetAmmoTypeFlag(PWEAPONTYPE pWeapon);
void SetAmmoTypeFlag(PWEAPONTYPE pWeapon, int nFlag, int nCustomAmmoType);
int GetAmmoUsedFlag(PWEAPONTYPE pWeapon);
void SetAmmoUsedFlag(PWEAPONTYPE pWeapon, int nFlag, int nCustomAmmoType);
BOOL IsMissileWeapon(PWEAPONTYPE pWeapon);
BOOL IsMissileWeapon(POBJECTTYPE pObject);
BOOL IsPoleArm(POBJECTTYPE pObject);
BOOL IsAmmo(PWEAPONTYPE pWeapon);
BOOL IsValidAmmoForWeapon(PWEAPONTYPE pWeapon, PWEAPONTYPE pAmmo);
BOOL IsValidAmmoForWeapon(PWEAPONTYPE pWeapon, POBJECTTYPE pAmmo);
//BOOL IsValidAmmoForWeapon(int nWeaponFlags, int nAmmoFlags);  // this was lazy you dork

BOOL IsThrowableWeapon(UINT nFlags);

int GetXPFromMonsterManual(PDNDMONSTERMANUALENTRY pMonster, int nHitDice, int nHitDicePlus, int nHitPoints);
int GetXPValueForCharacter(cDNDCharacter *pCharacter, int *pnSpecialAbility, int *pnExceptionalAbility);
int CalculateXP(int nHitDice, int nHitDicePlus, int nHitPoints, int nSpecialAbility, int nExceptionalAbility);
int GetAverageCharacterLevel(cDNDCharacter *pCharacter);

POBJECTTYPE FindDNDObjectByName(CString szItemName);
char *GetRandomJewelName();
char *GetRandomJewelryName(int *ValueDiv);
int FindTreasureTypeMultiplier(CString szTreasureType, CString szType);

BOOL RollMonsterMagicTreasure(cDNDNonPlayerCharacter *pNPC, int nMultiplier, int nPercentage, UINT nTableFlags); 
void RollMonsterJewelTreasure(cDNDNonPlayerCharacter *pNPC, int nMultiplier, int nPercentage, int nAmount, int nMinValue, int nMaxValue);
void RollMonsterJewelryTreasure(cDNDNonPlayerCharacter *pNPC, int nMultiplier, int nPercentage, int nAmount, int nMinValue, int nMaxValue);

void RollMonsterCoins(LONG *pCoinSlot, int nMultiplier, int nPercentage, int nDieRoll, int nCoinStacks);
void RollMonsterTreasure(cDNDNonPlayerCharacter *pNPC, PDNDMONSTERMANUALENTRY pMonster, BOOL bLair, BOOL bAddCoins);

void RollNPCharacterEquipment(cDNDNonPlayerCharacter *pNPC);
void RollNPCharacter_Helmets(cDNDNonPlayerCharacter *pNPC);
void RollNPCharacterEquipment_Fighter(cDNDNonPlayerCharacter *pNPC);
void RollNPCharacterEquipment_Cleric(cDNDNonPlayerCharacter *pNPC);
void RollNPCharacterEquipment_Thief(cDNDNonPlayerCharacter *pNPC);
void RollNPCharacterEquipment_Mage(cDNDNonPlayerCharacter *pNPC);
void RollNPCharacterMundaneEquipment(cDNDNonPlayerCharacter *pNPC);

void RollNPCharacterMagicEquipment(cDNDNonPlayerCharacter *pNPC);
void NPCharacterEquipItems(cDNDNonPlayerCharacter *pNPC);
void NPCharacterDropUnusedItems(cDNDNonPlayerCharacter *pNPC);


void NPCharacterGenerateSpellBook(cDNDCharacter *pCharacter, int nClassIndex, cDNDSpellBook *pSpellBook);
void NPCharacterGenerateSpells(cDNDCharacter *pCharacter);

DND_CHARACTER_ALIGNMENTS GetMagicSwordAlignment();
char *GetMagicSwordPrimaryAbility(int nIndex, int nDieRoll);
char *GetMagicSwordExtraordinaryPowers(int nIndex, int nDieRoll);
char *GetMagicSwordSpecialPurpose(int nIndex, int nDieRoll);
char *GetMagicSwordSpecialPurposePower(int nIndex, int nDieRoll);

typedef enum
{
	DND_SFX_STATE_UNDEF = 0,
	DND_SFX_STATE_READY,
	DND_SFX_STATE_TRIGGERED_START,
	DND_SFX_STATE_TRIGGERED,

} DND_SFX_STATES;

#define MAX_MAP_SFX	32

class cDNDMapSFX
{
public:

	char m_szSFXName[32];
	char m_szGFXFileName[256];
	char m_szSFXFileName[32];

	DND_SFX_STATES m_SFXState;
	BOOL m_bCycle;
	BOOL m_bAnimated;

	int m_nMapX;
	int m_nMapY;

	float m_fScale;

	LPVOID m_pDataPtr;

	int m_nReserved[32];

	cDNDMapSFX()
	{
		Init();
	}

	void Init()
	{
		memset(m_szSFXName, 0, 32 * sizeof(char));
		memset(m_szGFXFileName, 0, 256 * sizeof(char));
		memset(m_szSFXFileName, 0, 32 * sizeof(char));

		m_SFXState = DND_SFX_STATE_UNDEF;
		m_bCycle = FALSE;
		m_bAnimated = FALSE;

		m_nMapX = 0;
		m_nMapY = 0;

		m_fScale = 1.0f;

		m_pDataPtr = NULL;

		memset(m_nReserved, 0, 32 * sizeof(int));
	}

	~cDNDMapSFX()
	{
	}
};

#define MAX_MAP_CELLS	128

class cDNDMapCell
{
public:

	char m_szBitmapPath[MAX_PATH];
	int m_nReserved[128];
	Bitmap* m_pBitmap;

	cDNDMapCell()
	{
		memset(m_szBitmapPath, 0, MAX_PATH * sizeof(char)); 
		memset(m_nReserved, 0, 128 * sizeof(int)); 
		m_pBitmap = NULL;
	}

	~cDNDMapCell()
	{
		if(m_pBitmap != NULL)
		{
			delete m_pBitmap;
			m_pBitmap = NULL;
		}
	}

};


#if 0
#define MAX_PC_PARTY_MEMBERS 256		
#define MAX_NPC_PARTY_MEMBERS 256
#define MAX_PARTY_MEMBERS	(MAX_PC_PARTY_MEMBERS+MAX_NPC_PARTY_MEMBERS)
#define MAX_MAP_CACHES	512
#else
#define MAX_PC_PARTY_MEMBERS 256		
#define MAX_NPC_PARTY_MEMBERS 128
#define MAX_PARTY_MEMBERS	512		// yes this looks screwy because we had to modify for memory pigginess + backwards compatablilty reasons
#define MAX_MAP_CACHES	128
#endif

#define MAX_PARTY_WAYPOINTS	1024

class cDNDCacheInventory
{
public:

	DWORD	m_dwCacheID;
	DWORD	m_dwParentMapID;

	char m_szCacheDesc[128];
	char m_szCacheDetails[512];

	LONG m_lCopperCarried;
	LONG m_lSilverCarried;
	LONG m_lElectrumCarried;
	LONG m_lGoldCarried;
	LONG m_lPlatinumCarried;

	cDNDObject m_Inventory[MAX_CHARACTER_INVENTORY];

	float m_fMapLocationX;
	float m_fMapLocationY;

	float m_fLocalLocationX;
	float m_fLocalLocationY;

	unsigned long m_lSaveFlag;
	unsigned long m_lSavedFlag;

	int m_nReserved[1024];

	cDNDCacheInventory()
	{
		m_dwCacheID = 0L;
		m_dwParentMapID = 0L;

		m_lCopperCarried = 0L;
		m_lSilverCarried = 0L;
		m_lElectrumCarried = 0L;
		m_lGoldCarried = 0L;
		m_lPlatinumCarried = 0L;

		memset(m_szCacheDesc, 0, 128 * sizeof(char));
		memset(m_szCacheDetails, 0, 512 * sizeof(char));


		m_fMapLocationX = 0.0f;
		m_fMapLocationY = 0.0f;

		m_fLocalLocationX = 0.0f;
		m_fLocalLocationY = 0.0f;

		m_lSaveFlag = 0L;
		m_lSavedFlag = 0L;

		memset(m_nReserved, 0, 1024 * sizeof(int));
	}

	void MarkChanged()
	{
		++m_lSaveFlag;
	}
	void MarkSaved()
	{
		m_lSaveFlag = 0L;
		m_lSavedFlag = 0L;
	}
	BOOL IsChanged()
	{
		return (m_lSaveFlag != m_lSavedFlag);
	}

};

class cDNDTreasureCacheHeader
{
public:

	UINT	m_Version;
	DWORD	m_dwCacheID;
	DWORD	m_dwParentMapID;
	int		m_nCaches;
	
	int m_nReserved[2048];

	cDNDTreasureCacheHeader()
	{
		m_Version = DMH_CURRENT_VERSION;
		m_dwCacheID = 0L;
		m_dwParentMapID = 0L;
		m_nCaches = 0;

		memset(m_nReserved, 0, 2048 * sizeof(int));
	}

};

class cDNDTreasureCache
{
public:

	cDNDTreasureCacheHeader m_Header;

	cDNDCacheInventory m_Caches[MAX_MAP_CACHES];

	cDNDTreasureCache()
	{
	}

	int CountCaches()
	{
		m_Header.m_nCaches = 0;
		for(int i = 0; i < MAX_MAP_CACHES; ++i)
		{
			if(m_Caches[i].m_dwCacheID)
				++m_Header.m_nCaches;
		}

		return m_Header.m_nCaches;
	}

	void MarkChanged()
	{
		for(int i = 0; i < MAX_MAP_CACHES; ++i)
		{
			if(m_Caches[i].m_dwCacheID)
			{
				m_Caches[i].MarkChanged();
				return; //only need to flag one to save all
			}
		}
	}
	void MarkSaved()
	{
		for(int i = 0; i < MAX_MAP_CACHES; ++i)
		{
			if(m_Caches[i].m_dwCacheID)
			{
				m_Caches[i].MarkSaved();
			}
		}
	}
	BOOL IsChanged()
	{
		for(int i = 0; i < MAX_MAP_CACHES; ++i)
		{
			if(m_Caches[i].m_dwCacheID)
			{
				if(m_Caches[i].IsChanged())
				{
					return TRUE;
				}
			}
		}

		return FALSE;
	}

};

#define MAP_RESERVED_DATA_SIZE 32629  // was 32765
#define MAX_MAP_TILES	8192
#define MAP_RESERVED_DATA_SIZE_2 18989

class cDNDMapTile
{
public:

	int m_nTileX;
	int m_nTileY;

	int m_nTileFrame; 
	int m_nRoomFlag;
	int m_nRoomNumber;
	int m_nTileHeight;

	int m_nReserved[127];

	cDNDMapTile()
	{
		m_nTileX = 0;
		m_nTileY = 0;

		m_nTileFrame = 0;
		m_nRoomFlag = 0;
		m_nRoomNumber = 0;
		m_nTileHeight = 0;

		memset(m_nReserved, 0, 127 * sizeof(int));
	}

	~cDNDMapTile()
	{
	}
};

class cDNDMap
{
public:

	UINT	m_Version;
	DWORD	m_dwMapID;
	BOOL	m_bCampaignMap;

	int m_nRows;
	int m_nColumns;

	int m_nPixelSizeX;
	int m_nPixelSizeY;
	float m_fScaleX;	//pixel to miles relationship
	float m_fScaleY;	//pixel to miles relationship

	char m_szMapName[MAX_PATH];

	cDNDMapCell m_Cells[MAX_MAP_CELLS][MAX_MAP_CELLS];

	BOOL m_bMapScaleFeet;

	DWORD	m_dwParentMapID;
	BOOL	m_bMapScaledToParent;
	float   m_fParentMapOriginX;	// this is in MILES
	float   m_fParentMapOriginY;	// this is in MILES

	unsigned long m_lSaveFlag;
	unsigned long m_lSavedFlag;

	float m_fLatitude40NLine;
	float m_fDegreeLatitudeMiles;

	BOOL m_bTiles;

	DWORD m_dwRandomDungeonPartyID;

	char m_szLoadedFilename[512];

	BOOL m_bDisplayLayer[4];
	int m_nTransRed;
	int m_nTransGreen;
	int m_nTransBlue;

	int m_nMapIconScale;

	int m_nReserved[MAP_RESERVED_DATA_SIZE];

	cDNDMapTile m_Tiles[MAX_MAP_TILES];

	int m_nFogOfWarFlag;
	int m_nFogOfWarCell[100][100];

	cDNDMapSFX m_MapSFX[MAX_MAP_SFX];

	int m_nReserved2[MAP_RESERVED_DATA_SIZE_2];

	cDNDMap()
	{
		m_Version = DMH_CURRENT_VERSION;
		m_dwMapID = 0L;

		memset(m_szMapName, 0, MAX_PATH * sizeof(char)); 
		memset(m_nReserved, 0, MAP_RESERVED_DATA_SIZE * sizeof(int)); 
		memset(m_Tiles, 0, MAX_MAP_TILES * sizeof(cDNDMapTile));
		memset(m_nReserved2, 0, MAP_RESERVED_DATA_SIZE_2 * sizeof(int)); 

		m_nRows = 1;
		m_nColumns = 1;

		m_nPixelSizeX = 512;
		m_nPixelSizeY = 512;

		m_fScaleX = 1.0f;
		m_fScaleY = 1.0f;

		m_bMapScaleFeet = FALSE;

		m_dwParentMapID = 0;
		m_bMapScaledToParent = FALSE;
		m_fParentMapOriginX = 0.0f;
		m_fParentMapOriginY = 0.0f;		

		m_lSaveFlag = 0L;
		m_lSavedFlag = 0L;

		m_fLatitude40NLine = 0.0f;
		m_fDegreeLatitudeMiles = 0.0f;

		m_bTiles = FALSE;

		m_nMapIconScale = 0;

		m_nTransRed = 255;
		m_nTransGreen = 0;
		m_nTransBlue = 255;

		m_nFogOfWarFlag = 0;
		memset(m_nFogOfWarCell, 0, 100*100*sizeof(int));

		memset(m_szLoadedFilename, 0, 512 * sizeof(char));

		m_dwRandomDungeonPartyID = 0L;
	}

	~cDNDMap()
	{
	}

	void MarkChanged()
	{
		++m_lSaveFlag;
	}
	void MarkSaved()
	{
		m_lSaveFlag = 0L;
		m_lSavedFlag = 0L;
	}
	BOOL IsChanged()
	{
		return (m_lSaveFlag != m_lSavedFlag);
	}

};


class cDNDWayPoint
{
public:

	float	m_fX;
	float	m_fY;

	int m_nReserved[128];

	cDNDWayPoint()
	{
		m_fX = 0.0f;
		m_fY = 0.0f;

		memset(m_nReserved, 0, 128 * sizeof(int)); 
	}

	~cDNDWayPoint()
	{
	}

	void Clear()
	{
		m_fX = 0.0f;
		m_fY = 0.0f;

		memset(m_nReserved, 0, 128 * sizeof(int)); 
	}

	BOOL IsClear()
	{
		if(m_fX == 0.0f && m_fY == 0.0f)
			return TRUE;

		return FALSE;
	}

	void Copy(cDNDWayPoint *pWP)
	{
		m_fX = pWP->m_fX;
		m_fY = pWP->m_fY;

		memset(m_nReserved, 0, 128 * sizeof(int)); 
	}

};

class cDNDWeatherDay
{
public:

	float m_fMapX;
	float m_fMapY;

	int m_nMonth;
	int m_nDay;

	int m_nLowTemperature;
	int m_nHighTemperature;

	int m_nCloudsType;
	int m_nPrecipitationType;

	BOOL m_bRainbow;

	cDNDWeatherDay()
	{
		m_fMapX = 0.0f;
		m_fMapY = 0.0f;

		m_nMonth = -1;
		m_nDay = -1;

		m_nLowTemperature = 0;
		m_nHighTemperature = 0;

		m_nCloudsType;
		m_nPrecipitationType = 0;

		m_bRainbow = FALSE;
	}

};

#define MAX_WEATHER_FORECASTS	20

#define MAX_SUB_PARTIES	128

typedef enum
{
	DND_SUBPARTY_TYPE_UNDEF = 0,
	DND_SUBPARTY_TYPE_DUNGEON, 

} DND_SUBPARTY_TYPES;

class cDNDSubParty
{
public:

	DWORD	m_dwSubPartyID;
	char	m_szSubPartyName[128];
	int		m_nSubPartyType;

	int m_nReserved[94];  // total subparty size is set at 512 bytes = 128 ints

	cDNDSubParty()
	{
		m_dwSubPartyID = 0;
		memset(m_szSubPartyName, 0, 128*sizeof(char));
		m_nSubPartyType = DND_SUBPARTY_TYPE_UNDEF;
		memset(m_nReserved, 0, 94*sizeof(int));
	}

	~cDNDSubParty()
	{
	}
};

class cDNDParty
{
public:

	UINT	m_Version;
	DWORD	m_dwPartyID;
	char	m_szPartyName[256];


	int		m_nNumPartyMembers;
	DWORD	m_dwPartyRoster[MAX_PARTY_MEMBERS];	

	//time
	DWORD m_dwCalendarID;
	int m_nSegment;
	int m_nRound;
	int m_nTurn;
	int m_nHour;
	int m_nDayofWeek;
	int m_nDayofMonth;
	int m_nMonth;
	int m_nYear;

	char	m_szPartyMapName[128];
	DWORD	m_dwPartyMapID;
	float	m_fPartyLocationX;
	float	m_fPartyLocationY;

	float	m_fPartyLocalLocationX;
	float	m_fPartyLocalLocationY;

	BOOL m_bTravelling;
	cDNDWayPoint m_WayPoints[MAX_PARTY_WAYPOINTS];

	unsigned long m_lSaveFlag;
	unsigned long m_lSavedFlag;

	long m_lXP;

	int m_nPartyMovementRate;

	int m_nReserved1[1020];

	cDNDNonPlayerCharacter m_NPCs[MAX_NPC_PARTY_MEMBERS];

	cDNDWeatherDay m_WeatherForecast[MAX_WEATHER_FORECASTS];

	cDNDSubParty m_SubParty[MAX_SUB_PARTIES];

	int m_nReserved2[16203];


	cDNDParty()
	{
		m_Version = DMH_CURRENT_VERSION;
		m_dwPartyID = 0L;
		m_nNumPartyMembers = 0;

		memset(m_szPartyName, 0, 256 * sizeof(char)); 
		memset(m_dwPartyRoster, 0, MAX_PARTY_MEMBERS * sizeof(DWORD)); 

		m_dwCalendarID = 0;
		m_nSegment = 0;
		m_nRound = 0;
		m_nTurn = 0;
		m_nHour = 0;
		m_nDayofWeek = 0;
		m_nDayofMonth = 0;
		m_nMonth = 0;
		m_nYear = 0;

		memset(m_szPartyMapName, 0, 128*sizeof(char));
		m_dwPartyMapID = 0;
		m_fPartyLocationX = 0.0f;
		m_fPartyLocationY = 0.0f;

		m_fPartyLocalLocationX = 0.0f;
		m_fPartyLocalLocationY = 0.0f;
		
		m_bTravelling = FALSE;

		m_lSaveFlag = 0L;
		m_lSavedFlag = 0L;

		m_lXP = 0L;

		m_nPartyMovementRate = 0;

		memset(m_nReserved1, 0, 1020 * sizeof(int)); 

		memset(m_nReserved2, 0, 16203 * sizeof(int)); 

	}

	~cDNDParty()
	{
		TRACE("DELETING PARTY\n");
	}

	void ClearWayPoints()
	{
		for(int i = 0; i < MAX_PARTY_WAYPOINTS ; ++i)
		{
			m_WayPoints[i].Clear();
		}
	}

	void ValidatePartyRoster();
	void ValidateNPCList();
	void ValidateSubParties();
	void AddPartyMemberID(DWORD dwID);
	void RemovePartyMemberID(DWORD dwID);
	cDNDNonPlayerCharacter* GetOpenNPCSlot();
	void RemovePocketPCs();

	BOOL CharacterIsPartyMember(cDNDCharacter *pCharacter);
	BOOL CharacterIsPartyMember(cDNDNonPlayerCharacter *pNPC);
	BOOL CharacterIsPartyMember(DWORD dwCharacterID);
	

	void ModifyCalendar(DND_CALENDAR_MOD_TYPES nSet, DND_CALENDAR_MOD_TYPES nSetType, int nValue = -9999);

	void CollapseRoute();
	float TravelRoute(float fDistanceToTravel);

	BOOL EatRations();

	void MarkChanged();
	void MarkSaved();
	BOOL IsChanged();


};

//////////////////////////////////////////////////////////

#define MAX_RANDOM_NAME_TABLE_ENTRIES	1024

class cDNDRandomNameDataTable
{
public:

	CString m_szTableName;

	CString m_szFirstNameFirstSyllable[MAX_RANDOM_NAME_TABLE_ENTRIES];
	CString m_szFirstNameLastSyllable[MAX_RANDOM_NAME_TABLE_ENTRIES];

	CString m_szLastNameFirstSyllable[MAX_RANDOM_NAME_TABLE_ENTRIES];
	CString m_szLastNameLastSyllable[MAX_RANDOM_NAME_TABLE_ENTRIES];
	CString m_szFinishNameSyllable[MAX_RANDOM_NAME_TABLE_ENTRIES];

	int m_nSyllables[5];


	void Reset()
	{
		m_szTableName = _T("");

		for(int i = 0; i < MAX_RANDOM_NAME_TABLE_ENTRIES; ++i)
		{
			m_szFirstNameFirstSyllable[i] = _T("");
			m_szFirstNameLastSyllable[i] = _T("");

			m_szLastNameFirstSyllable[i] = _T("");
			m_szLastNameLastSyllable[i] = _T("");

			m_szFinishNameSyllable[i] = _T("");
		}

		memset(m_nSyllables, 0, 5 * sizeof(int));
	}

	cDNDRandomNameDataTable()
	{
		Reset();
	}

	~cDNDRandomNameDataTable()
	{
	}
};
#define PDNDRANDOMNAMEDATATABLE cDNDRandomNameDataTable*
typedef CTypedPtrArray <CPtrArray, PDNDRANDOMNAMEDATATABLE> PDNDRANDOMNAMEDATATABLEARRAY;



class cDNDRandomNameTable
{
public:

	DND_CHARACTER_RACES m_Race;

	int m_nNameDataSize[2];
	PDNDRANDOMNAMEDATATABLEARRAY m_NameDataArray[2]; // 0 is male, 1 is female
	
	void Reset()
	{
		m_Race = DND_CHARACTER_RACES_UNDEF;
		m_nNameDataSize[0] = 0;
		m_nNameDataSize[1] = 0;

		for(int j = 0;  j < 2; ++j)
		{
			for (int i = 0; i < m_NameDataArray[j].GetSize(); ++i )
			{
				PDNDRANDOMNAMEDATATABLE pDataTable = (PDNDRANDOMNAMEDATATABLE)m_NameDataArray[j].GetAt(i);

				if(pDataTable != NULL)
				{
					delete pDataTable;
				}
			}
		}
	}

	cDNDRandomNameTable(DND_CHARACTER_RACES nRace)
	{
		Reset();

		m_Race = nRace;
	}

	cDNDRandomNameTable()
	{
		Reset();
	}

	~cDNDRandomNameTable()
	{
		Reset();
	}
};

#define PDNDRANDOMNAMETABLE cDNDRandomNameTable*
typedef CTypedPtrMap <CMapWordToPtr, WORD, PDNDRANDOMNAMETABLE> PDNDRANDOMNAMETABLEMAP;


void GenerateAmmoForWeapons(cDNDCharacter *pCharacter, PWEAPONTYPE pWeapon);


/*
Kobold (12): AC 7; MV 6"; HD 1-4 hit points; hp 4(x8), 2(x2), 1(x2); #AT 1; Dmg 1-4 or by weapon; AL LE; SIZE S; XP 98; MM p.57.
Weasel, Giant: AC 6; MV 15"; HD 3+3; hp 12; #AT 1; Dmg 2-12; SA successful strike drains blood for 2-12; AL N; SIZE M; XP 173; MM p.100.
*/

typedef CTypedPtrMap <CMapWordToPtr, WORD, WORD*> PDNDSTATHPMAP;

class cDNDStatBlock
{
public:

	CString m_szName;
	int m_nNumber;
	CString m_szAC;
	CString m_szMove;
	CString m_szHD;

	int m_HitPointsCount[MAX_NPC_PARTY_MEMBERS];	//HP if there are multiple creatures in the block
	int m_HitPointsValue[MAX_NPC_PARTY_MEMBERS];	//HP if there are multiple creatures in the block

	CString m_szAttacks;
	CString m_szDamage;
	CString m_szAlignment;
	CString m_szSize;
	int m_nXP;

	CString m_szSpecialAttack;
	CString m_szSpecialDefense;

	CString m_szPage;

	cDNDStatBlock()
	{
		Reset();
	};

	~cDNDStatBlock()
	{
		Reset();
	}

	void Reset()
	{
		m_szName = "";
		m_nNumber = 0;
		m_szAC = "";
		m_szMove = "";
		m_szHD = "";
		
		memset(m_HitPointsCount, 0, MAX_NPC_PARTY_MEMBERS*sizeof(int));	
		memset(m_HitPointsValue, 0, MAX_NPC_PARTY_MEMBERS*sizeof(int));

		m_szAttacks = "";
		m_szDamage = "";
		m_szAlignment = "";
		m_szSize = "";
		m_nXP = 0;

		m_szSpecialAttack = "";
		m_szSpecialDefense = "";

		m_szPage = "";
	};

	void AddHitPointsCount(int nHP)
	{
		int nIndex = 0;
		BOOL bFoundSlot = FALSE;
		do
		{
			if (m_HitPointsCount[nIndex] == 0 || m_HitPointsValue[nIndex] == 0 || m_HitPointsValue[nIndex] == nHP)
			{
				++m_HitPointsCount[nIndex];
				m_HitPointsValue[nIndex] = nHP;
				bFoundSlot = TRUE;
			}

			++nIndex;

		} while (bFoundSlot == FALSE && nIndex < MAX_NPC_PARTY_MEMBERS);
	};

	void SortHPCount()
	{
		for (int i = 0; i < m_nNumber - 1; ++i)
		{
			for (int j = i; j < m_nNumber; ++j)
			{
				if (m_HitPointsValue[i] < m_HitPointsValue[j])
				{
					int nJunk = m_HitPointsValue[i];
					m_HitPointsValue[i] = m_HitPointsValue[j];
					m_HitPointsValue[j] = nJunk;

					nJunk = m_HitPointsCount[i];
					m_HitPointsCount[i] = m_HitPointsCount[j];
					m_HitPointsCount[j] = nJunk;
				}
			}
		}
	};

};

#define PDNDSTATBLOCK cDNDStatBlock*
typedef CTypedPtrMap <CMapStringToPtr, CString, PDNDSTATBLOCK> PDNDSTATBLOCKMAP;

//utility functions
void RemoveSpaces(char *szInString);
void RemoveLineFeeds(char *szInString);

char *GetNumberSuffix(int nNumber);

CString szPlusOrMinus(int nVal);

CString GetStringFromInt(int nVal);

CString GetCharacterSize(int nHeight);

CString GetCharacterBook(DND_CHARACTER_CLASSES nClass);

CString GetNumberth(int nNumber);

#endif 

/*
APPENDIX 0: ENCUMBRANCE OF STANDARD ITEMS
Item Encumbrance in gold pieces
Backpack 20
Belt 3
Belt pouch, large 10
 small 5
Book, large metal?bound 200
Boots, hard 60
 soft 30
Bottles, flagons 60
Bow, composite long 80
 composite short 50
 long 100
 short 50
Caltrop 50
Candle 5
Chest, large solid iron 1000-5000
 small solid iron 200-500 
 small wooden 100-250
 large wooden 500-1500
Clothes (1 set) 30
Cord, 10' 2
Crossbow, heavy 80
 light 50
Crystal ball, base and wrapping 150
Flask, empty 7
 full 20 
Gem 1-5
Grapnel 100
Hand tool 10
Helm 45 
Helm, great 100
Holy water, potion bottles 25
Horn 50
Jewelry, large 50
 small 1-5
Lantern 60
Mirror 5
Musical instrument* 350
Pole, 10' 100
Purse 1
Quiver 30
Rations, iron 75
 standard 200
Robe or cloak, folded 50
 worn 25
Rod 60
Rope, 50' 75
Sack, large 20 
 small 5
Saddle, light horse 250 
 heavy horse 500
Saddlebag 150
Saddle blanket (pad) 20
Scroll case, bone or ivory 50
 leather 25
Spike 10 
Staff 100
Tapestry (very small to huge) 50-1000+
Tinderbox 2
Torch 25
Wand, bone or ivory case 60
 box 80
 leather case 30
Waterskin or wineskin, empty 5
 full 50
* Musical instruments include only large and bulky instruments such as lutes and drums.
The maximum weight a normal?strength person can carry and still move is 1500 g.p. (150#).
Certain items are not included when figuring encumbrance. These include:
 material components (unless large and bulky).
 any helm but great helm, if the character has any armor.
 one set of clothing.
 thieves' picks and tools.

*/